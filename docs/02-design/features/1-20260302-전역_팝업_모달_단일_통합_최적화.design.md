# 전역 모달 시스템 단일화 통합 설계서 (Design)

## 1. 아키텍처 구조 변경 방향 (As-Is vs To-Be)

### As-Is (파편화된 지역 모달 아키텍처)

기존 시스템은 버튼과 모달 컴포넌트가 하나의 파일 안에서 밀결합(Tightly-coupled)되어 있으며, 모달의 열림 상태를 각 컴포넌트가 로컬 상태(`useState`)로 독립 관리합니다.

1. 버튼 컴포넌트 내부에서 `<Dialog>` 엘리먼트를 직접 렌더링.
2. `popstate`(뒤로가기) 이벤트 감지 센서가 누락되어 브라우저 뒤로가기 시 팝업만 화면에 둥둥 떠 있는 심각한 버그 발생.
3. 스크롤 강제 잠금(`pointer-events: none`)이 중첩 시 꼬여서 좀비 오버레이 양산.

### To-Be (중앙집중식 `ModalContext` 아키텍처)

모든 모달을 특정 위치에서 렌더링하지 않고, 리액트 최상단의 Context Provider가 배열(`Stack`) 형태로 보관하다가 화면 맨 위에 뿌려주는 **명령형 호출** 방식으로 완전히 패러다임을 전환합니다.

1. `ModalContext`만이 유일하게 `<Dialog>` 엘리먼트를 화면에 주입.
2. 각 화면에서는 `<Dialog>` 컴포넌트를 그리지 않고, `openModal(내_모달_이름)` 이라는 자바스크립트 명령 함수만 실행.
3. 중앙 관제탑이 `popstate` 리스너를 단 1개만 운용하여, 브라우저 뒤로가기 시 맨 위에 있는 모달 스택부터 LIFO(Last-In First-Out) 원칙으로 차례대로 파괴.

---

## 2. 코어 보강 설계: 비파괴형(Non-destructive) Popstate

기존 `ModalContext`의 약점인 "URL 파라미터 파괴" 구조를 뜯어고칩니다.

**수정 대상: `ModalContext.tsx` 의 URL 갱신부**

- 기존: URL 경로와 파라미터를 무시하고 단순 문자열 치환을 하거나 모달 고유 주소로 덮어씀.
- **설계 변경**:
  - 팝업 Open 시: `window.location.search`를 통해 현재 가지고 있는 파라미터(예: `?tab=admin...`) 일체와 기존 경로(`/admin`)를 합친 후, 그 뒤에 **`#modal-{고유ID}` 형태의 해시태그 앵커만 덧붙임**. (`pushState`)
  - 팝업 Close 시: `#modal-{고유ID}` 영역만 잘라내어 URL에서 삭제.

---

## 3. 리팩토링 구현 표준 가이드 (Refactoring Guideline)

모든 지역 모달 컴포넌트를 치환할 때 아래의 규칙을 엄격하게 적용하여 빠짐없이 균일하게 수정합니다.

### Step A: 모달 UI 독립 분리 추출

기존 파일의 렌더 함수(Return) 안에 박혀있던 `<Dialog>`들을 통째로 잘라내어 독립적인 순수 컴포넌트(Pure Component)로 만듭니다.

- **규칙**: 컴포넌트 내부에 `open`, `onOpenChange` 속성들은 완전히 제거하고, 항상 자신이 열려있는 상태라고 가정하고 설계합니다 (열고 닫는 통제권은 Context가 쥐기 때문).

### Step B: 뷰 모델(View)에서 `useModalContext` 호출

모달을 그렸던 원본 파일에서는 이제 껍데기를 모두 삭제하고 버튼의 OnClick 이벤트만 훅으로 연결합니다.

```tsx
import { useModalContext } from "@/contexts/ModalContext";
import { TargetPopupComponent } from "./TargetPopupComponent";

export default function MyPage() {
  const { openModal } = useModalContext();

  return (
    <Button
      onClick={() =>
        openModal("unique-id", TargetPopupComponent, { 전달할_Props })
      }
    >
      모달 열기
    </Button>
  );
}
```

### Step C: 팝업, 바텀시트, 알럿 형태 무관성 보장

- `ModalContext` 시스템 내부에서는 전달받은 순수 컴포넌트를 그대로 포장(Wrap)하여 뿌리므로, 전달되는 `TargetPopupComponent`가 `shadcn/ui`의 `<Sheet>`이든 `<AlertDialog>`이든 무관하게 완벽하게 똑같이 렌더링되며 뒤로가기 탈취 효과를 받습니다.

## 4. 부작용 방어 및 오류율 0% 유지 전략

- 대량의 Props를 상속하던 레거시 지역 모달들을 함수(명령형)에 파라미터로 실어서 넘길 때, `TypeScript` 인터페이스 충돌이 다발할 수 있습니다.
- 모든 이관 작업은 1개의 화면 컴포넌트(예: 검수대기) 단위로 완료 후 즉각 빌드 에러를 체크하고, 수동 렌더링 검사 후 다음 파일로 넘어가는 **점진적 컷오버(Gradual Cut-over) 방식**을 수행하여 대규모 크래시를 원천 봉쇄합니다.
