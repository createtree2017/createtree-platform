import type { Express, Request } from "express";
import express from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { z } from "zod";
import multer from "multer";
import path from "path";
import fs from "fs";
import jwt from "jsonwebtoken";
import QRCode from "qrcode";
import { QR_CONFIG } from "../shared/qr-config";
// import { authMiddleware } from "./common/middleware/auth"; // ì„ì‹œ ë¹„í™œì„±í™”

import musicEngineRouter from "./routes/music-engine-routes";
import collageRouter from "./routes/collage";
import bannerMigrationRouter from "./routes/banner-migration";
import milestoneRoutes from "./routes/milestone-routes";
import chatRoutes from "./routes/chat-routes";

import { generateThumbnail, getThumbnailUrl } from "./utils/thumbnail";
import { saveImageToGCS, saveImageFromUrlToGCS, saveBannerToGCS } from "./utils/gcs-image-storage";
import { applyTemplateVariables } from "./utils/prompt";
import { 
  getSystemSettings, 
  updateSystemSettings, 
  refreshSettingsCache,
  checkSystemSettingsHealth,
  resolveAiModel,
  getValidModelsForConcept,
  validateRequestedModel
} from "./utils/settings";



import googleOAuthRouter from "./routes/google-oauth";
import imageRouter from "./routes/image";
import { requireAuth } from "./middleware/auth";
import { requireAdminOrSuperAdmin, requireHospitalAdmin } from "./middleware/admin-auth";
import { requirePremiumAccess, requireActiveHospital } from "./middleware/permission";
import { errorHandler, notFoundHandler, asyncHandler } from "./middleware/error-handler";
import { requestLogger, responseFormatter } from "./middleware/response";
import { getUserImages } from "./storage";
import { createUploadMiddleware } from "./config/upload-config";

// Express session íƒ€ì… í™•ì¥
declare module 'express-session' {
  interface SessionData {
    tempImage?: {
      id: number;
      title: string;
      style: string;
      originalUrl: string;
      transformedUrl: string;
      createdAt: string;
      isTemporary: boolean;
      localFilePath?: string; // ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œ ì¶”ê°€
      dbImageId?: number; // ì‹¤ì œ DBì— ì €ì¥ëœ IDë„ ì¶”ê°€
    };

    // Firebase ì¸ì¦ ê´€ë ¨ ì„¸ì…˜ í•„ë“œ ì¶”ê°€
    userId?: number;
    firebaseUid?: string;
    userEmail?: string;
    userRole?: string;
    isAdmin?: boolean;
    isHospitalAdmin?: boolean;
  }
}
// Chat ì‹œìŠ¤í…œì—ì„œëŠ” simple ë²„ì „ìœ¼ë¡œ importí•˜ê³ , ì´ë¯¸ì§€ëŠ” DALL-E 3 ë²„ì „ì„ ì‚¬ìš©
import { generateChatResponse } from "./services/openai";

// Upload middleware ìƒì„±
const imageUpload = createUploadMiddleware('thumbnails', 'image');

// ê³µí†µ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
// Type safety helper functions
const normalizeOptionalString = (value: string | null | undefined): string | undefined => {
  return value === null ? undefined : value;
};

const isError = (error: unknown): error is Error => {
  return error instanceof Error;
};

const getErrorMessage = (error: unknown): string => {
  if (isError(error)) {
    return error.message;
  }
  return String(error);
};

function getUserId(req: Request): string {
  const userId = req.user?.id || req.user?.userId;
  return String(userId);
}

function validateUserId(req: Request, res: express.Response): string | null {
  const userId = getUserId(req);
  if (!userId || userId === 'undefined') {
    console.error("âŒ ì‚¬ìš©ì IDê°€ ì—†ìŠµë‹ˆë‹¤:", req.user);
    res.status(400).json({
      success: false,
      message: "ì‚¬ìš©ì ì¸ì¦ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤."
    });
    return null;
  }
  return userId;
}

import { generateContent } from "./services/gemini";
import {
  generateAiMusic,
  getAvailableMusicStyles,
  getAvailableDurations
} from "./services/topmedia-service";
// import geminiTestRoutes from "./routes/gemini-test-routes"; // ì œê±°ë¨
import { exportChatHistoryAsHtml } from "./services/export-logs";


import {
  music,
  images,
  personas,
  personaCategories,
  concepts,
  conceptCategories,
  abTests,
  abTestVariants,
  serviceItems,
  abTestResults,
  hospitals,
  hospitalMembers,
  musicStyles,
  insertMusicStyleSchema,
  banners,
  smallBanners,  // ì‘ì€ ë°°ë„ˆ í…Œì´ë¸” ì¶”ê°€

  // styleCards ì œê±°ë¨

  serviceCategories,
  users,
  userNotificationSettings,
  hospitalCodes,
  milestones,
  milestoneApplications,

  // ì‹œìŠ¤í…œ ì„¤ì • ê´€ë ¨ ì¶”ê°€
  systemSettings,
  systemSettingsUpdateSchema,
  AI_MODELS,

  insertConceptSchema,
  insertConceptCategorySchema,
  insertBannerSchema,
  insertHospitalCodeSchema,

  insertServiceCategorySchema,
  insertServiceItemSchema,
  sql,
  like
} from "../shared/schema";
import { db } from "../db/index";
import { or, ne, eq, and, asc, desc, isNull, inArray } from "drizzle-orm";

// Configure multer for file uploads
const uploadDir = path.join(process.cwd(), "uploads");
const staticBannerDir = path.join(process.cwd(), "static", "banner");
const staticMilestoneDir = path.join(process.cwd(), "static", "milestones");

// Create directories if they don't exist
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}
if (!fs.existsSync(staticBannerDir)) {
  fs.mkdirSync(staticBannerDir, { recursive: true });
  fs.mkdirSync(path.join(staticBannerDir, "slide-banners"), { recursive: true });
  fs.mkdirSync(path.join(staticBannerDir, "small-banners"), { recursive: true });
}
if (!fs.existsSync(staticMilestoneDir)) {
  fs.mkdirSync(staticMilestoneDir, { recursive: true });
}

const storage2 = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, file.fieldname + "-" + uniqueSuffix + path.extname(file.originalname));
  },
});

// Static í´ë”ìš© multer ì„¤ì • (ë°°ë„ˆ ì „ìš©)
const bannerStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    // ì„ì‹œë¡œ ëª¨ë“  íŒŒì¼ì„ uploads í´ë”ì— ì €ì¥
    // ì‹¤ì œ í´ë” êµ¬ë¶„ì€ ì—…ë¡œë“œ í›„ íŒŒì¼ ì´ë™ìœ¼ë¡œ ì²˜ë¦¬
    console.log('ğŸ“ [BANNER STORAGE] ===== DESTINATION í•¨ìˆ˜ í˜¸ì¶œ =====');
    console.log('ğŸ“ [BANNER STORAGE] req.body:', req.body);
    console.log('ğŸ“ [BANNER STORAGE] file info:', {
      originalname: file.originalname,
      mimetype: file.mimetype,
      fieldname: file.fieldname
    });

    // ì„ì‹œ ì €ì¥ì†Œ ì‚¬ìš© (ë‚˜ì¤‘ì— APIì—ì„œ ì˜¬ë°”ë¥¸ í´ë”ë¡œ ì´ë™)
    const tempPath = path.join(process.cwd(), 'uploads');

    console.log('ğŸ“ [BANNER STORAGE] ì„ì‹œ ì €ì¥ ê²½ë¡œ:', tempPath);

    // í´ë”ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    const exists = fs.existsSync(tempPath);
    console.log('ğŸ“ [BANNER STORAGE] í´ë” ì¡´ì¬ ì—¬ë¶€:', exists);

    if (!exists) {
      console.log('ğŸ“ [BANNER STORAGE] í´ë” ìƒì„± ì‹œë„:', tempPath);
      try {
        fs.mkdirSync(tempPath, { recursive: true });
        console.log('ğŸ“ [BANNER STORAGE] âœ… í´ë” ìƒì„± ì„±ê³µ');
      } catch (error) {
        console.error('ğŸ“ [BANNER STORAGE] âŒ í´ë” ìƒì„± ì‹¤íŒ¨:', error);
      }
    }

    console.log('ğŸ“ [BANNER STORAGE] ===== DESTINATION ì™„ë£Œ =====');
    cb(null, tempPath);
  },
  filename: function (req, file, cb) {
    console.log('ğŸ“ [BANNER STORAGE] ===== FILENAME í•¨ìˆ˜ í˜¸ì¶œ =====');
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    const filename = "banner-" + uniqueSuffix + path.extname(file.originalname);
    console.log('ğŸ“ [BANNER STORAGE] ìƒì„±ëœ íŒŒì¼ëª…:', filename);
    console.log('ğŸ“ [BANNER STORAGE] íŒŒì¼ í™•ì¥ì:', path.extname(file.originalname));
    console.log('ğŸ“ [BANNER STORAGE] ===== FILENAME ì™„ë£Œ =====');
    cb(null, filename);
  },
});

const upload = multer({
  storage: multer.memoryStorage(), // ë©”ëª¨ë¦¬ ì €ì¥ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ buffer ì‚¬ìš©
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  fileFilter: (req, file, cb) => {
    console.log('ğŸ“ íŒŒì¼ ì—…ë¡œë“œ ì‹œë„:', { fieldname: file.fieldname, mimetype: file.mimetype, originalname: file.originalname });

    const allowedTypes = [
      "image/jpeg",
      "image/jpg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/heic",
      "image/heif"
    ];

    if (!allowedTypes.includes(file.mimetype)) {
      console.error('âŒ í—ˆìš©ë˜ì§€ ì•ŠëŠ” íŒŒì¼ íƒ€ì…:', file.mimetype);
      return cb(new Error(`í—ˆìš©ë˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. í—ˆìš© í˜•ì‹: ${allowedTypes.join(', ')}`));
    }

    console.log('âœ… íŒŒì¼ íƒ€ì… ê²€ì¦ í†µê³¼:', file.mimetype);
    cb(null, true);
  },
});

// ë§ˆì¼ìŠ¤í†¤ í—¤ë” ì´ë¯¸ì§€ìš© multer ì„¤ì •
const milestoneStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, staticMilestoneDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, "milestone-header-" + uniqueSuffix + path.extname(file.originalname));
  },
});

const milestoneUpload = multer({
  storage: milestoneStorage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.') as any, false);
    }
  },
});

// ë°°ë„ˆ ì „ìš© multer ì—…ë¡œë“œ (static í´ë” ì‚¬ìš©)
const bannerUpload = multer({
  storage: bannerStorage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  fileFilter: (req, file, cb) => {
    const allowedTypes = ["image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp"];
    if (!allowedTypes.includes(file.mimetype)) {
      return cb(new Error(`í—ˆìš©ë˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. í—ˆìš© í˜•ì‹: ${allowedTypes.join(', ')}`));
    }
    cb(null, true);
  },
});



// Schema for favorite toggle
const favoriteToggleSchema = z.object({
  itemId: z.number().int().positive(),
  type: z.enum(["music", "image"]),
});

// Schema for media sharing
const mediaShareSchema = z.object({
  id: z.number().int(), // -1 ê°’ë„ í—ˆìš©
  type: z.enum(["music", "image"]),
});

// Schema for persona creation/update
const personaSchema = z.object({
  personaId: z.string().min(1, "Persona ID is required"),
  name: z.string().min(1, "Name is required"),
  avatarEmoji: z.string().min(1, "Avatar emoji is required"),
  description: z.string().min(1, "Description is required"),
  welcomeMessage: z.string().min(1, "Welcome message is required"),
  systemPrompt: z.string().min(1, "System prompt is required"),
  primaryColor: z.string().min(1, "Primary color is required"),
  secondaryColor: z.string().min(1, "Secondary color is required"),

  // Additional fields (optional)
  personality: z.string().optional(),
  tone: z.string().optional(),
  usageContext: z.string().optional(),
  emotionalKeywords: z.array(z.string()).optional(),
  timeOfDay: z.enum(["morning", "afternoon", "evening", "night", "all"]).default("all"),

  // Admin fields (optional with defaults)
  isActive: z.boolean().default(true),
  isFeatured: z.boolean().default(false),
  order: z.number().int().default(0),

  // Categories
  categories: z.array(z.string()).optional(),
});

// Schema for persona category creation/update
const personaCategorySchema = z.object({
  categoryId: z.string().min(1, "Category ID is required"),
  name: z.string().min(1, "Name is required"),
  description: z.string().min(1, "Description is required"),
  emoji: z.string().min(1, "Emoji is required"),
  order: z.number().int().default(0),
  isActive: z.boolean().default(true),
});

// Schema for concept category creation/update
const conceptCategorySchema = z.object({
  categoryId: z.string().min(1, "Category ID is required"),
  name: z.string().min(1, "Name is required"),
  description: z.string().optional(),
  systemPrompt: z.string().optional(), // GPT-4o ì´ë¯¸ì§€ ë¶„ì„ ì§€ì¹¨ í•„ë“œ ì¶”ê°€
  order: z.number().int().default(0),
  isActive: z.boolean().default(true),
});

// Schema for image generation request
const imageGenerationSchema = z.object({
  prompt: z.string().min(1, "Prompt is required"),
});

// Schema for concept creation/update
const conceptSchema = z.object({
  conceptId: z.string().min(1, "Concept ID is required"),
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  promptTemplate: z.string().min(1, "Prompt template is required"),
  systemPrompt: z.string().optional(), // GPT-4o ì´ë¯¸ì§€ ë¶„ì„ ì§€ì¹¨ í•„ë“œ ì¶”ê°€
  thumbnailUrl: z.string().optional(),
  tagSuggestions: z.array(z.string()).optional(),
  variables: z.array(
    z.object({
      name: z.string().min(1, "Variable name is required"),
      label: z.string().min(1, "Variable label is required"),
      placeholder: z.string().optional()
    })
  ).optional(),
  referenceImageUrl: z.string().optional(),
  categoryId: z.string().optional(),
  isActive: z.boolean().default(true),
  isFeatured: z.boolean().default(false),
  order: z.number().int().default(0),
  // AI ëª¨ë¸ ê´€ë ¨ í•„ë“œ ì¶”ê°€
  generationType: z.enum(["image_upload", "text_only"]).default("image_upload"),
  availableModels: z.array(z.string()).min(1, "ìµœì†Œ 1ê°œ ì´ìƒì˜ AI ëª¨ë¸ì„ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤").optional(),
  availableAspectRatios: z.record(z.string(), z.array(z.string())).optional(),
  // ë³‘ì›ë³„ ê³µê°œ ì„¤ì • í•„ë“œ ì¶”ê°€
  visibilityType: z.enum(["public", "hospital"]).default("public"),
  hospitalId: z.number().int().optional(),
});

// ì¸ì¦ ë¼ìš°íŠ¸ ê°€ì ¸ì˜¤ê¸°
import authRoutes from "./routes/auth";
// ì¸ì¦ ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
import { initPassport } from "./services/auth";
import cookieParser from "cookie-parser";
import session from "express-session";
import { placeholderRouter } from './routes/placeholder';
// import musicRouter from './routes/music-routes'; // ì¤‘ë³µ ì œê±°

// import testOpenAIRouter from './routes/test-openai-route'; // ì œê±°ë¨

// ìƒˆë¡œìš´ ì—­í• ë³„ ë¼ìš°íŠ¸ íŒŒì¼ë“¤
import { registerAdminRoutes } from './routes/admin-routes';
import { registerHospitalRoutes } from './routes/hospital-routes';
import { registerPublicRoutes } from './routes/public-routes';

export async function registerRoutes(app: Express): Promise<Server> {

  // ì—­í• ë³„ ë¼ìš°íŠ¸ ë“±ë¡
  registerAdminRoutes(app);
  registerHospitalRoutes(app);
  registerPublicRoutes(app);

  // ğŸ”¥ GCS ì—…ë¡œë“œ í…ŒìŠ¤íŠ¸ ì—”ë“œí¬ì¸íŠ¸ (ì¸ì¦ ì—†ìŒ, ìµœìš°ì„  ë“±ë¡)
  const multerModule = await import('multer');
  const multerTest = multerModule.default;
  const uploadTest = multerTest({ dest: 'temp/' });

  // [PUBLIC] GCS upload test endpoint
  app.post('/api/gcs-test', uploadTest.single('file'), async (req, res) => {
    try {
      console.log('ğŸ§ª GCS í…ŒìŠ¤íŠ¸ ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œë¨');

      if (!req.file) {
        return res.status(400).json({ error: 'íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.' });
      }

      const { bucket } = await import('./firebase') as { bucket: any };
      const fs = await import('fs');

      const userId = 'test-user';
      const file = req.file;
      // ì‘ì—…ì§€ì‹œì„œ: GCS ê²½ë¡œ êµ¬ì¡°ë¡œ ë³€ê²½
      const destination = `${userId}/${Date.now()}_${file.originalname}`;

      console.log('ğŸ“¤ GCS ì—…ë¡œë“œ ì‹œì‘:', destination);

      // GCSì— ì—…ë¡œë“œ (ê³µê°œ ëª¨ë“œ)
      await bucket.upload(file.path, {
        destination,
        metadata: {
          contentType: file.mimetype,
        },
        public: true, // ê³µê°œ íŒŒì¼ë¡œ ì„¤ì •
      });

      // ì„ì‹œ íŒŒì¼ ì‚­ì œ
      fs.unlinkSync(file.path);

      // ê³µê°œ URL ìƒì„±
      const publicUrl = `https://storage.googleapis.com/${bucket.name}/${destination}`;

      console.log('âœ… GCS ì—…ë¡œë“œ ì„±ê³µ:', destination);
      res.status(200).json({
        success: true,
        url: publicUrl,
        gsPath: `gs://${bucket.name}/${destination}`,
        message: 'GCS ì—…ë¡œë“œ í…ŒìŠ¤íŠ¸ ì„±ê³µ',
        bucket: bucket.name,
        destination: destination
      });

    } catch (error: any) {
      console.error('âŒ GCS ì—…ë¡œë“œ ì‹¤íŒ¨:', error);

      // ì„ì‹œ íŒŒì¼ì´ ìˆë‹¤ë©´ ì‚­ì œ
      const fsModule = await import('fs');
      if (req.file && fsModule.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
      }

      res.status(500).json({
        success: false,
        error: 'GCS ì—…ë¡œë“œ ì‹¤íŒ¨',
        details: error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'
      });
    }
  });

  // ğŸ”¥ GCS ì—…ë¡œë“œ ë¼ìš°í„° ë“±ë¡
  const { default: uploadRouter } = await import('./routes/upload');
  app.use('/api/upload', uploadRouter);

  // ğŸ¯ Milestone ë¼ìš°í„° ë“±ë¡
  app.use('/api', milestoneRoutes);

  // ì´ë¯¸ì§€ ì„œë¹™ ë¼ìš°í„° (í•„ìš”ì‹œ í™œì„±í™”)
  // const { default: imageRouter } = await import('./routes/images');
  // app.use('/api/images', imageRouter);

  // ê´€ë¦¬ì ë„êµ¬ ë¼ìš°í„° (í•„ìš”ì‹œ í™œì„±í™”)
  // const { default: adminToolsRouter } = await import('./routes/admin-tools');
  // app.use('/api/admin-tools', adminToolsRouter);



  // [ì¤‘ë³µ ì œê±°ë¨] Small banners, user profile, notifications - public-routes.tsë¡œ ì´ë™

  // [LEGACY] ê¸°ì¡´ ë¼ìš°íŠ¸ë“¤ - ì—­í• ë³„ ë¼ìš°íŠ¸ íŒŒì¼ë¡œ ë¶„ë¦¬ë¨
  // ë‹¤ìŒ ë¼ìš°íŠ¸ë“¤ì€ ìƒˆë¡œìš´ íŒŒì¼ì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤:
  // - admin-routes.ts: ê´€ë¦¬ì ì „ìš© ë¼ìš°íŠ¸ (89ê°œ)
  // - hospital-routes.ts: ë³‘ì› ê´€ë¦¬ì ë¼ìš°íŠ¸ (23ê°œ)
  // - public-routes.ts: ê³µê°œ/ì¸ì¦ ì‚¬ìš©ì ë¼ìš°íŠ¸ (51ê°œ)









  // âš ï¸ ì¤‘ë³µ ì œê±°ë¨: admin-routes.tsì—ì„œ ì²˜ë¦¬

  // ğŸš¨ ì¤‘ë³µ ë¼ìš°í„° ì œê±°ë¨ - ìƒë‹¨ì˜ ìƒˆë¡œìš´ ë¼ìš°í„° ì‚¬ìš©

  // ì¿ í‚¤ íŒŒì„œ ë¯¸ë“¤ì›¨ì–´ ë“±ë¡
  app.use(cookieParser());

  // ì„¸ì…˜ ë¯¸ë“¤ì›¨ì–´ ë“±ë¡ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
  app.use(session({
    secret: process.env.SESSION_SECRET || 'create-tree-mobile-session-secret',
    resave: false,             // ì„¸ì…˜ ë³€ê²½ì‚¬í•­ì´ ì—†ìœ¼ë©´ ì €ì¥ ì•ˆí•¨ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
    saveUninitialized: false,  // ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ì„¸ì…˜ ì €ì¥ ì•ˆí•¨
    cookie: {
      httpOnly: true,
      secure: false,
      sameSite: 'lax',
      path: '/',
      maxAge: 30 * 24 * 60 * 60 * 1000  // 30ì¼
    },
    name: 'createtree.sid'
  }));

  // Passport ì´ˆê¸°í™” ë° ë¯¸ë“¤ì›¨ì–´ ë“±ë¡
  const passport = initPassport();
  app.use(passport.initialize());
  app.use(passport.session());

  // ğŸ—‘ï¸ ë³µì¡í•œ ìŠ¤íƒ€ì¼ì¹´ë“œ ì‹œìŠ¤í…œ ì™„ì „íˆ ì œê±°ë¨

  // âœ… ê¸°ì¡´ banners í…Œì´ë¸” í™œìš© - ë³µì¡í•œ ì‹œìŠ¤í…œ ì œê±°í•˜ê³  ê°„ë‹¨í•˜ê²Œ!

  // ì¸ì¦ ë¼ìš°íŠ¸ ë“±ë¡
  app.use("/api/auth", authRoutes);

  // í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ ë¼ìš°íŠ¸ ë“±ë¡
  app.use("/api/placeholder", placeholderRouter);

  // ìŠˆí¼ê´€ë¦¬ì ë¼ìš°íŠ¸ ë“±ë¡
  // ìŠˆí¼ê´€ë¦¬ì ë¼ìš°í„° ì œê±°ë¨ - í†µí•© ê´€ë¦¬ì ì‹œìŠ¤í…œ ì‚¬ìš©

  // ìŒì•… ê´€ë ¨ API ë¼ìš°íŠ¸ ë“±ë¡ (music-engine-routes.tsë¡œ í†µí•©ë¨)

  // OpenAI API í…ŒìŠ¤íŠ¸ ë¼ìš°íŠ¸ ë“±ë¡
  // app.use("/api/test-openai", testOpenAIRouter); // ì œê±°ë¨

  // í†µí•© ë©”ë‰´ API - ì¹´í…Œê³ ë¦¬ì™€ ì„œë¹„ìŠ¤ í•­ëª©ì„ í•¨ê»˜ ì œê³µ
  app.get("/api/menu", async (req, res) => {
    try {
      // 1. í™œì„±í™”ëœ ì„œë¹„ìŠ¤ ì¹´í…Œê³ ë¦¬ ê°€ì ¸ì˜¤ê¸° (ê³µê°œ ìƒíƒœì¸ ê²ƒë§Œ)
      const categories = await db.select().from(serviceCategories)
        .where(eq(serviceCategories.isPublic, true))
        .orderBy(serviceCategories.order);

      if (!categories || categories.length === 0) {
        return res.status(200).json([]);
      }

      // 2. ë©”ë‰´ êµ¬ì¡° ìƒì„±
      const menu = [];

      // 3. ê° ì¹´í…Œê³ ë¦¬ë³„ë¡œ í•´ë‹¹í•˜ëŠ” ì„œë¹„ìŠ¤ í•­ëª© ì¡°íšŒ
      for (const category of categories) {
        // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ì†í•œ í™œì„±í™”ëœ ì„œë¹„ìŠ¤ í•­ëª©ë§Œ ê°€ì ¸ì˜¤ê¸°
        const items = await db.select({
          id: serviceItems.id,
          title: serviceItems.title,
          path: serviceItems.path, // DBì˜ path í•„ë“œ ì§ì ‘ ì‚¬ìš© (itemId ì¤‘ë³µ ì œê±°)
          iconName: serviceItems.icon // ì•„ì´ì½˜ ì´ë¦„ (ì¼ê´€ì„± ìœ ì§€)
        }).from(serviceItems)
          .where(and(
            eq(serviceItems.categoryId, category.id),
            eq(serviceItems.isPublic, true)
          ))
          .orderBy(serviceItems.order);

        // í•­ëª©ì´ ìˆëŠ” ì¹´í…Œê³ ë¦¬ë§Œ ë©”ë‰´ì— ì¶”ê°€
        if (items && items.length > 0) {
          menu.push({
            id: category.id,
            title: category.title,
            icon: category.icon, // ì¹´í…Œê³ ë¦¬ ì•„ì´ì½˜ (icons í•„ë“œ)
            items: items.map(item => ({
              ...item,
              // pathê°€ ì´ë¯¸ ìŠ¬ë˜ì‹œë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸ í›„ ë³€í™˜
              path: item.path?.startsWith('/') ? item.path : `/${item.path}`
            }))
          });
        }
      }

      console.log("ë©”ë‰´ êµ¬ì¡°:", JSON.stringify(menu));
      return res.status(200).json(menu);
    } catch (error) {
      console.error('ë©”ë‰´ ì¡°íšŒ ì˜¤ë¥˜:', error);
      return res.status(500).json({ error: "menu-error" });
    }
  });




  // ì‹œìŠ¤í…œ ì„¤ì • ì¡°íšŒ API (ê³µê°œìš© - í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚¬ìš©)
  app.get("/api/system-settings", async (req, res) => {
    try {
      console.log("[ì‹œìŠ¤í…œ ì„¤ì • ì¡°íšŒ] í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ ë°›ìŒ");
      
      const settings = await getSystemSettings();
      
      // í´ë¼ì´ì–¸íŠ¸ì— í•„ìš”í•œ ì„¤ì •ë§Œ ë°˜í™˜ (ë³´ì•ˆìƒ ë¯¼ê°í•œ ì •ë³´ ì œì™¸)
      const publicSettings = {
        supportedAiModels: settings.supportedAiModels,
        clientDefaultModel: settings.clientDefaultModel,
        defaultAiModel: settings.defaultAiModel
      };
      
      console.log("[ì‹œìŠ¤í…œ ì„¤ì • ì¡°íšŒ] í´ë¼ì´ì–¸íŠ¸ìš© ì„¤ì • ë°˜í™˜:", publicSettings);
      
      res.json({
        success: true,
        settings: publicSettings
      });
      
    } catch (error) {
      console.error("[ì‹œìŠ¤í…œ ì„¤ì • ì¡°íšŒ] í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ ì˜¤ë¥˜:", error);
      
      // ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ê°’ ë°˜í™˜
      const fallbackSettings = {
        supportedAiModels: [AI_MODELS.OPENAI, AI_MODELS.GEMINI],
        clientDefaultModel: AI_MODELS.OPENAI,
        defaultAiModel: AI_MODELS.OPENAI
      };
      
      res.json({
        success: true,
        settings: fallbackSettings
      });
    }
  });

  // Serve uploaded files from the uploads directory
  app.use('/uploads', (req, res, next) => {
    // ì •ì  íŒŒì¼ ì œê³µ - ì§ì ‘ íŒŒì¼ ì½ê³  ì œê³µ
    const filePath = path.join(process.cwd(), 'uploads', req.path);
    console.log(`Serving static file: ${filePath}`);
    res.sendFile(filePath, (err) => {
      if (err) {
        console.error(`Error serving static file: ${filePath}`, err);
        next();
      }
    });
  });

  // ì„ì‹œ ì´ë¯¸ì§€ íŒŒì¼ ì œê³µ (ë³„ë„ ë¼ìš°íŠ¸ë¡œ ì²˜ë¦¬)
  app.use('/uploads/temp', (req, res, next) => {
    // ì„ì‹œ íŒŒì¼ ì œê³µ
    const tempFilePath = path.join(process.cwd(), 'uploads', 'temp', req.path);
    console.log(`Serving temporary file: ${tempFilePath}`);
    res.sendFile(tempFilePath, (err) => {
      if (err) {
        console.error(`Error serving temporary file: ${tempFilePath}`, err);
        next();
      }
    });
  });

  // GCS ì´ë¯¸ì§€ í”„ë¡ì‹œ ì„œë¹™ (ê¶Œí•œ ë¬¸ì œ í•´ê²°)
  app.get('/api/image-proxy/*', async (req, res) => {
    try {
      const { bucket } = await import('./firebase') as { bucket: any };
      const filePath = (req.params as any)[0]; // * captures everything after /api/image-proxy/
      console.log(`ğŸ–¼ï¸ ì´ë¯¸ì§€ í”„ë¡ì‹œ ìš”ì²­: ${filePath}`);

      const file = bucket.file(filePath);
      const [exists] = await file.exists();

      if (!exists) {
        return res.status(404).json({ error: 'Image not found' });
      }

      // íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ì§ì ‘ ì „ì†¡
      const stream = file.createReadStream();

      // ì ì ˆí•œ Content-Type ì„¤ì •
      const contentType = filePath.endsWith('.webp') ? 'image/webp' :
                         filePath.endsWith('.jpg') || filePath.endsWith('.jpeg') ? 'image/jpeg' :
                         filePath.endsWith('.png') ? 'image/png' : 'image/webp';

      res.setHeader('Content-Type', contentType);
      res.setHeader('Cache-Control', 'public, max-age=31536000'); // ì¼ë°˜ ì´ë¯¸ì§€ ìºì‹œ ì •ì±…

      stream.pipe(res);

      stream.on('error', (error: unknown) => {
        console.error('âŒ ì´ë¯¸ì§€ ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜:', error);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Failed to load image' });
        }
      });

    } catch (error) {
      console.error('âŒ ì´ë¯¸ì§€ í”„ë¡ì‹œ ì˜¤ë¥˜:', error);
      res.status(500).json({ error: 'Image proxy error' });
    }
  });

  // Serve embed script for iframe integration
  app.get('/embed.js', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'client/public/embed.js'));
  });

  // ê°œë°œ ëŒ€í™” ë‚´ë³´ë‚´ê¸° í˜ì´ì§€ ì œê³µ
  app.get('/dev-chat-export', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'client/public/dev-chat-export.html'));
  });



  // API routes

  // Music endpoints


  // ìŒì•… ëª©ë¡ APIëŠ” /api/music ë¼ìš°í„°ì—ì„œ ì²˜ë¦¬ë¨ (ì¤‘ë³µ ì œê±°)

  // ìŒì•… ê´€ë ¨ ëª¨ë“  APIëŠ” /api/music-engineìœ¼ë¡œ í†µí•©ë¨ (ì¤‘ë³µ ì œê±°)

  // ğŸ”¥ í…ŒìŠ¤íŠ¸ìš© ê°„ë‹¨í•œ API
  app.get("/api/public/test", (req, res) => {
    console.log("[í…ŒìŠ¤íŠ¸] ê³µê°œ API í˜¸ì¶œë¨");
    res.json({ message: "í…ŒìŠ¤íŠ¸ ì„±ê³µ!" });
  });

  // ì²« ë²ˆì§¸ ì¤‘ë³µ ë¼ìš°íŠ¸ëŠ” ì œê±°ë˜ì—ˆìŒ

  // ğŸ”¥ ì¸ì¦ ì—†ëŠ” ì´ë¯¸ì§€ ë³€í™˜ API (ì„ì‹œ ê°œë°œìš©)
  app.post("/api/public/image-transform", upload.single("image"), async (req, res) => {
    console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] API í˜¸ì¶œë¨ - íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘");
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No image file uploaded" });
      }

      const { style, userVariables } = req.body;
      if (!style) {
        return res.status(400).json({ error: "No style selected" });
      }

      console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] íŒŒì¼ ì—…ë¡œë“œë¨:", req.file.filename);
      console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] ìŠ¤íƒ€ì¼:", style);

      // ì‚¬ìš©ì ë³€ìˆ˜ íŒŒì‹±
      let parsedUserVariables = {};
      if (userVariables) {
        try {
          parsedUserVariables = JSON.parse(userVariables);
          console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] ì‚¬ìš©ì ë³€ìˆ˜:", parsedUserVariables);
        } catch (e) {
          console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] ë³€ìˆ˜ íŒŒì‹± ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©");
        }
      }

      // ê¸°ì¡´ ì´ë¯¸ì§€ ë³€í™˜ ë¡œì§ê³¼ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
      const originalImagePath = req.file.path;
      const imageId = Date.now();

      // OpenAI API í˜¸ì¶œ
      const imageBuffer = fs.readFileSync(originalImagePath);
      const base64Image = imageBuffer.toString('base64');

      // ì»¨ì…‰ ì •ë³´ ì¡°íšŒí•˜ì—¬ í”„ë¡¬í”„íŠ¸ ìƒì„±
      const publicConceptInfo = await db.query.concepts.findFirst({
        where: eq(concepts.conceptId, style)
      });

      // í”„ë¡¬í”„íŠ¸ ìƒì„± - ì»¨ì…‰ ì •ë³´ ë˜ëŠ” ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
      let prompt = publicConceptInfo?.promptTemplate || `Transform this image into ${style} style, maintaining the original composition and subjects while applying the artistic style transformation.`;

      // ì‚¬ìš©ì ë³€ìˆ˜ê°€ ìˆìœ¼ë©´ í”„ë¡¬í”„íŠ¸ì— ì ìš©
      if (parsedUserVariables && Object.keys(parsedUserVariables).length > 0) {
        Object.entries(parsedUserVariables).forEach(([key, value]) => {
          prompt = prompt.replace(`{{${key}}}`, value as string);
        });
      }

      console.log(`[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] ìƒì„±ëœ í”„ë¡¬í”„íŠ¸: ${prompt}`);

      const OpenAI = (await import('openai')).default;
      const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

      let transformedImageUrl;

      // GPT-Image-1 ëª¨ë¸ë§Œ ì‚¬ìš© (DALL-E 3 í´ë°± ì œê±°)
      console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] GPT-Image-1 ëª¨ë¸ ì‹œë„");
      const response = await openai.images.generate({
        model: "gpt-image-1",
        prompt: prompt,
        n: 1,
        size: "1024x1024",
        quality: "standard",
      });
      if (!response.data || !response.data[0]?.url) {
        throw new Error("No image generated from GPT-Image-1");
      }
      transformedImageUrl = response.data[0].url;
      console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] GPT-Image-1 ì„±ê³µ");

      console.log("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] OpenAI ì‘ë‹µ ì„±ê³µ");

      // ì»¨ì…‰ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¹´í…Œê³ ë¦¬ì™€ ì œëª© ê²°ì •
      const categoryId = publicConceptInfo?.categoryId || 'sticker_img';
      const conceptTitle = publicConceptInfo?.title || style;
      const imageTitle = `${conceptTitle}_${style}_ê²ŒìŠ¤íŠ¸`;

      console.log(`[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] ì¹´í…Œê³ ë¦¬ë³„ ì €ì¥: ${categoryId}`);
      console.log(`[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] ìƒˆë¡œìš´ ì œëª© í˜•ì‹: ${imageTitle}`);

      // GCSì— ì´ë¯¸ì§€ ì €ì¥
      const { saveImageFromUrlToGCS } = await import('./utils/gcs-image-storage');

      const imageResult = await saveImageFromUrlToGCS(
        transformedImageUrl,
        'guest', // ê²ŒìŠ¤íŠ¸ ì‚¬ìš©ì
        categoryId,
        imageTitle
      );

      console.log(`[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] GCS ì €ì¥ ì™„ë£Œ: ${imageResult.originalUrl}`);

      // DBì— ì´ë¯¸ì§€ ì €ì¥ - GCS URLë§Œ ì‚¬ìš©
      const [savedImage] = await db.insert(images).values({
        title: imageTitle,
        style: style,
        originalUrl: imageResult.originalUrl, // GCS ì›ë³¸ ì´ë¯¸ì§€ URL (ë¡œì»¬ ê²½ë¡œ ì œê±°)
        transformedUrl: imageResult.originalUrl, // GCS ì›ë³¸ ì´ë¯¸ì§€ URL
        thumbnailUrl: imageResult.thumbnailUrl, // GCS ì¸ë„¤ì¼ URL
        userId: "-1", // ê²ŒìŠ¤íŠ¸ ì‚¬ìš©ì
        categoryId: categoryId,
        conceptId: style,
        metadata: JSON.stringify({
          originalStyle: style,
          originalName: req.file?.filename || 'guest_upload',
          createdAt: new Date().toISOString(),
          displayTitle: imageTitle,
          gsPath: imageResult.gsPath, // GCS ê²½ë¡œ ì¶”ê°€
          gsThumbnailPath: imageResult.gsThumbnailPath, // GCS ì¸ë„¤ì¼ ê²½ë¡œ ì¶”ê°€
          fileName: imageResult.fileName,
          storageType: 'gcs',
          isShared: true
        })
      }).returning();

      console.log(`[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] DB ì €ì¥ ì™„ë£Œ: ID ${savedImage.id}`);

      return res.json({
        success: true,
        imageId: savedImage.id,
        transformedUrl: imageResult.originalUrl, // GCS ì›ë³¸ ì´ë¯¸ì§€
        thumbnailUrl: imageResult.thumbnailUrl, // GCS ì¸ë„¤ì¼
        originalUrl: req.file ? (await saveImageToGCS(req.file.buffer, 'anonymous', 'original')).originalUrl : null,
        message: "ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."
      });

    } catch (error) {
      console.error("[ê³µê°œ ì´ë¯¸ì§€ ë³€í™˜] ì˜¤ë¥˜:", error);
      return res.status(500).json({
        error: "ì´ë¯¸ì§€ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        details: getErrorMessage(error)
      });
    }
  });

  // ê¸°ì¡´ ì¸ì¦ í•„ìš”í•œ ì´ë¯¸ì§€ ë³€í™˜ API
  // JWT ê¸°ë°˜ ì´ë¯¸ì§€ ë³€í™˜ API - requireAuth ë¯¸ë“¤ì›¨ì–´ ì ìš©
  app.post("/api/image/transform", requireAuth, upload.single("image"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No image file uploaded" });
      }

      const { style, categoryId, variables } = req.body;
      if (!style) {
        return res.status(400).json({ error: "No style selected" });
      }

      console.log(`[ì´ë¯¸ì§€ ë³€í™˜] ì¹´í…Œê³ ë¦¬ ID ìˆ˜ì‹ : ${categoryId}`);
      console.log("[DEBUG] req.body ì „ì²´:", req.body);
      console.log("[DEBUG] req.body.variables:", req.body.variables);
      console.log("[DEBUG] req.user:", req.user);


      // Check if this is a request from admin panel or if it's a variant request for A/B testing
      const isTransformAdmin = req.query.admin === 'true' || req.headers['x-admin-request'] === 'true';
      const variantId = req.body.variant;
      let promptTemplate = null;
      let categorySystemPrompt = null;  // ë³€ìˆ˜ ë¯¸ë¦¬ ì •ì˜ (scope ë¬¸ì œ í•´ê²°)

      if (variantId) {
        // Get the active test for this concept/style
        const activeTest = await db.query.abTests.findFirst({
          where: and(
            eq(abTests.conceptId, style),
            eq(abTests.isActive, true)
          ),
        });

        if (activeTest) {
          // Find the requested variant
          const variant = await db.query.abTestVariants.findFirst({
            where: and(
              eq(abTestVariants.testId, activeTest.testId),
              eq(abTestVariants.variantId, variantId)
            ),
          });

          if (variant) {
            promptTemplate = variant.promptTemplate;

            // ë³€í˜• í…ŒìŠ¤íŠ¸ì—ë„ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì§€ì› ì¶”ê°€
            // ì›ë³¸ ì»¨ì…‰ì˜ systemPrompt ë˜ëŠ” ì¹´í…Œê³ ë¦¬ systemPrompt ê°€ì ¸ì˜¤ê¸°
            const concept = await db.query.concepts.findFirst({
              where: eq(concepts.conceptId, style)
            });

            if (concept) {
              if (concept.systemPrompt) {
                categorySystemPrompt = concept.systemPrompt;
                console.log(`A/B í…ŒìŠ¤íŠ¸ìš© ì»¨ì…‰ '${concept.title}'ì˜ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì ìš©: ${categorySystemPrompt.substring(0, 50)}...`);
              } else if (concept.categoryId) {
                const category = await db.query.conceptCategories.findFirst({
                  where: eq(conceptCategories.categoryId, concept.categoryId)
                });

                if (category && category.systemPrompt) {
                  categorySystemPrompt = category.systemPrompt;
                  console.log(`A/B í…ŒìŠ¤íŠ¸ìš© ì¹´í…Œê³ ë¦¬ '${category.name}'ì˜ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì ìš©: ${categorySystemPrompt.substring(0, 50)}...`);
                }
              }
            }
          }
        }
      }
      else {
        // Check if this is a custom concept from the database
        const concept = await db.query.concepts.findFirst({
          where: eq(concepts.conceptId, style)
        });

        // ì¹´í…Œê³ ë¦¬ ì •ë³´ì™€ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ê°€ì ¸ì˜¤ê¸° (ì´ë¯¸ì§€ ë¶„ì„ ì§€ì¹¨ìš©)
        if (concept && concept.categoryId) {
          const category = await db.query.conceptCategories.findFirst({
            where: eq(conceptCategories.categoryId, concept.categoryId)
          });

          if (category && category.systemPrompt) {
            categorySystemPrompt = category.systemPrompt;
            console.log(`ì¹´í…Œê³ ë¦¬ '${category.name}'ì˜ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì ìš©: ${categorySystemPrompt.substring(0, 50)}...`);
          }
        }

        if (concept) {
          // Use the prompt template from the concept
          promptTemplate = concept.promptTemplate;
          // ì»¨ì…‰ ìì²´ì˜ systemPromptê°€ ìˆë‹¤ë©´ ìš°ì„  ì ìš©
          if (concept.systemPrompt) {
            categorySystemPrompt = concept.systemPrompt;
            console.log(`ì»¨ì…‰ '${concept.title}'ì˜ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì ìš©: ${categorySystemPrompt.substring(0, 50)}...`);
          }
        }
      }

      // ì‚¬ìš©ì ë³€ìˆ˜ ì²˜ë¦¬ ë° í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì ìš©
      let processedPromptTemplate = promptTemplate;
      let processedSystemPrompt = categorySystemPrompt;

      // ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë³€ìˆ˜ê°’ë“¤ì„ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ê³¼ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ì ìš©
      console.log("[DEBUG] req.body ì „ì²´:", req.body);
      console.log("[DEBUG] req.body.variables:", req.body.variables);
      if (req.body.variables) {
        try {
          const userVariables = JSON.parse(req.body.variables);
          console.log("[ë§Œì‚­ì‚¬ì§„ ë³€í™˜] ì‚¬ìš©ì ë³€ìˆ˜:", userVariables);

          // ê³µí†µ ë³€ìˆ˜ ì¹˜í™˜ í•¨ìˆ˜ ì‚¬ìš© (ê¸°ì¡´ {var}ì™€ ìƒˆë¡œìš´ {{var}} í˜•ì‹ ëª¨ë‘ ì§€ì›)
          console.log(`ğŸ”„ [ë³€ìˆ˜ ì¹˜í™˜] í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ê³¼ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ë³€ìˆ˜ ì ìš© ì¤‘...`);
          processedPromptTemplate = applyTemplateVariables(processedPromptTemplate || '', userVariables);
          processedSystemPrompt = applyTemplateVariables(normalizeOptionalString(processedSystemPrompt) || '', userVariables);

          console.log("[ë³€ìˆ˜ ì¹˜í™˜] ìµœì¢… í”„ë¡¬í”„íŠ¸:", processedPromptTemplate);
          console.log("[ë³€ìˆ˜ ì¹˜í™˜] ìµœì¢… ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸:", processedSystemPrompt);
        } catch (error) {
          console.log("[ë³€ìˆ˜ ì¹˜í™˜] ì‚¬ìš©ì ë³€ìˆ˜ íŒŒì‹± ì‹¤íŒ¨, ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©");
        }
      }

      // íŒŒì¼ ë²„í¼ ì²˜ë¦¬ - ë©”ëª¨ë¦¬ ì €ì¥ ë°©ì‹ ì§€ì›
      let imageBuffer: Buffer;

      if (req.file.buffer && req.file.buffer.length > 0) {
        // ë©”ëª¨ë¦¬ ì €ì¥ ë°©ì‹
        imageBuffer = req.file.buffer;
        console.log("ğŸ“ ìŠ¤í‹°ì»¤ ìƒì„± - ë©”ëª¨ë¦¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');
      } else if (req.file.path) {
        // ë””ìŠ¤í¬ ì €ì¥ ë°©ì‹ - íŒŒì¼ ê²½ë¡œì—ì„œ ì½ê¸°
        const originalImagePath = req.file.path;
        imageBuffer = fs.readFileSync(originalImagePath);
        console.log("ğŸ“ ìŠ¤í‹°ì»¤ ìƒì„± - ë””ìŠ¤í¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');

        // ì„ì‹œ íŒŒì¼ ì‚­ì œ
        fs.unlinkSync(originalImagePath);
      } else {
        console.error("âŒ ìŠ¤í‹°ì»¤ ìƒì„± - íŒŒì¼ ë²„í¼ì™€ ê²½ë¡œ ëª¨ë‘ ì—†ìŒ");
        return res.status(500).json({
          success: false,
          message: "ì—…ë¡œë“œëœ íŒŒì¼ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        });
      }

      // ì„ì‹œ íŒŒì¼ ìƒì„±í•˜ì—¬ ê¸°ì¡´ transformImage ë©”ì„œë“œ ì‚¬ìš©
      const tempDir = path.join(process.cwd(), 'temp');
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      const tempFilePath = path.join(tempDir, `temp_${Date.now()}_${req.file.originalname}`);
      fs.writeFileSync(tempFilePath, imageBuffer);

      let transformedImageUrl: string;

      try {
        // Process image using AI service (transforming to specified art style)
        transformedImageUrl = await storage.transformImage(
          tempFilePath,
          style,
          processedPromptTemplate,
          processedSystemPrompt
        );

        // ì„ì‹œ íŒŒì¼ ì •ë¦¬
        if (fs.existsSync(tempFilePath)) {
          fs.unlinkSync(tempFilePath);
        }

        console.log("âœ… [ìŠ¤í‹°ì»¤ ìƒì„±] ì´ë¯¸ì§€ ë³€í™˜ ì™„ë£Œ:", transformedImageUrl);

        if (!transformedImageUrl || transformedImageUrl.includes('placehold.co')) {
          console.error("ğŸš¨ ìŠ¤í‹°ì»¤ ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨");
          return res.status(500).json({
            success: false,
            message: "ì´ë¯¸ì§€ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
          });
        }
      } catch (error) {
        // ì„ì‹œ íŒŒì¼ ì •ë¦¬
        if (fs.existsSync(tempFilePath)) {
          fs.unlinkSync(tempFilePath);
        }
        console.error("âŒ [ìŠ¤í‹°ì»¤ ìƒì„±] ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨:", error);
        return res.status(500).json({
          success: false,
          message: "ì´ë¯¸ì§€ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
        });
      }

      // Check if this is a request from admin panel or if it's a variant test
      // Admin ìš”ì²­ì´ê±°ë‚˜ A/B í…ŒìŠ¤íŠ¸ ë³€í˜•ì¼ ê²½ìš°ì—ë§Œ DBì— ì €ì¥
      const isAdminRequest = req.query.admin === 'true' || req.headers['x-admin-request'] === 'true';
      const isVariantTest = !!variantId;

      let savedImage;
      let dbSavedImage;

      try {
        // JWTì—ì„œ ì¸ì¦ëœ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸° (requireAuth ë¯¸ë“¤ì›¨ì–´ì—ì„œ ì„¤ì •ë¨)
        const userId = req.user!.userId;
        const username = req.user!.username;

        // ìš”ì²­ ì •ë³´ ìì„¸íˆ ë¡œê¹…
        console.log(`[ì´ë¯¸ì§€ ë³€í™˜] ìš”ì²­ ì‹œì‘ - ì‹œê°„: ${new Date().toISOString()}`);
        console.log(`[ì´ë¯¸ì§€ ë³€í™˜] íŒŒì¼: ${req.file.originalname}, ìŠ¤íƒ€ì¼: ${style}`);
        console.log(`[ì´ë¯¸ì§€ ë³€í™˜] ìš”ì²­ í—¤ë”: admin=${req.query.admin}, x-admin-request=${req.headers['x-admin-request']}`);
        console.log(`[ì´ë¯¸ì§€ ë³€í™˜] JWT ì¸ì¦ëœ ì‚¬ìš©ì ${username} (ID: ${userId})`);

        // ëª¨ë“  ì´ë¯¸ì§€ ìš”ì²­ì€ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ (ì‚¬ìš©ì ì •ë³´ í¬í•¨)
        console.log(`[ì´ë¯¸ì§€ ë³€í™˜] ì´ë¯¸ì§€ ì €ì¥ ì‹œì‘: ${style} ${req.file.originalname}`);

        dbSavedImage = await storage.saveImageTransformation(
          req.file.originalname,
          style,
          tempFilePath,
          transformedImageUrl,
          userId, // JWT ì¸ì¦ í›„ í•­ìƒ ì¡´ì¬
          username, // JWT ì¸ì¦ í›„ í•­ìƒ ì¡´ì¬
          categoryId, // ì¹´í…Œê³ ë¦¬ IDê°€ ë¨¼ì €
          variantId // ë³€í˜• IDê°€ ë‚˜ì¤‘
        );

        console.log(`[ì´ë¯¸ì§€ ë³€í™˜] ì´ë¯¸ì§€ ì €ì¥ ì„±ê³µ: ID=${dbSavedImage.id}, ì œëª©=${dbSavedImage.title}`);

        if (isAdminRequest || isVariantTest) {
          // ê´€ë¦¬ì íŒ¨ë„ì´ë‚˜ A/B í…ŒìŠ¤íŠ¸ ìš”ì²­ì€ DB ì´ë¯¸ì§€ ì§ì ‘ ë°˜í™˜
          savedImage = dbSavedImage;
          console.log(`ê´€ë¦¬ì ìš”ì²­: ì´ë¯¸ì§€ê°€ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ë¨ (ID: ${dbSavedImage.id})`);
        } else {
          // ì¼ë°˜ ì‚¬ìš©ì ìš”ì²­ì¸ ê²½ìš° - ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ì€ í–ˆì§€ë§Œ ì„ì‹œ ê°ì²´ë¡œ ì‘ë‹µ
          console.log(`ì¼ë°˜ ì‚¬ìš©ì ì´ë¯¸ì§€: DBì— ì €ì¥ë¨ (ID: ${dbSavedImage.id}), ì‚¬ìš©ìì—ê²ŒëŠ” ì„ì‹œ ì´ë¯¸ì§€ë¡œ ì œê³µ`);

          // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì»¨ì…‰ ì •ë³´ ì¡°íšŒí•˜ì—¬ ì œëª© ë™ì  ê²°ì •
          const conceptInfo = await db.query.concepts.findFirst({
            where: eq(concepts.conceptId, style)
          });

          const conceptTitle = conceptInfo?.title || style;
          const title = `${conceptTitle}_${style}_${username}`;
          const tempImageResult = await storage.saveTemporaryImage(transformedImageUrl, title);
          console.log("[ë””ë²„ê·¸] tempImageResult êµ¬ì¡°:", tempImageResult);

          // ì„ì‹œ ì‘ë‹µ ê°ì²´ ìƒì„± (JWT ì¸ì¦ í›„ì—ëŠ” ì„¸ì…˜ ë¶ˆí•„ìš”)
          savedImage = {
            id: -1, // -1ì€ ì €ì¥ë˜ì§€ ì•Šì€ ì„ì‹œ ID
            title,
            style,
            originalUrl: tempFilePath,
            transformedUrl: transformedImageUrl, // ì‘ì—…ì§€ì‹œì„œ: ë¡œì»¬ ê²½ë¡œ ì œê±°, GCS URLë§Œ ì‚¬ìš©
            localFilePath: (tempImageResult as any).localPath || tempFilePath, // ì „ì²´ íŒŒì¼ ê²½ë¡œ (ë‚´ë¶€ ì‚¬ìš©)
            createdAt: new Date().toISOString(),
            isTemporary: true, // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„ì‹œ ì—¬ë¶€ ì‹ë³„ì„ ìœ„í•œ í”Œë˜ê·¸
            dbImageId: dbSavedImage.id // ì‹¤ì œ DBì— ì €ì¥ëœ ID (í•„ìš”ì‹œ ì‚¬ìš©)
          };

          console.log(`[ì´ë¯¸ì§€ ë³€í™˜] JWT ì¸ì¦ëœ ì‚¬ìš©ì ${username}ì˜ ì„ì‹œ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ`);
          console.log(`[ì´ë¯¸ì§€ ë³€í™˜] ì´ë¯¸ì§€ ID: ${dbSavedImage.id}, ì„ì‹œ ê²½ë¡œ: ${savedImage.transformedUrl}`);
        }
      } catch (error) {
        console.error("[ì´ë¯¸ì§€ ë³€í™˜] ì´ë¯¸ì§€ ì €ì¥ ì¤‘ ì˜¤ë¥˜:", error);

        // ì˜¤ë¥˜ ë‚´ìš© ìƒì„¸íˆ ë¡œê¹…
        console.error("[ì´ë¯¸ì§€ ë³€í™˜] ì˜¤ë¥˜ ì„¸ë¶€ ì •ë³´:", {
          message: getErrorMessage(error),
          stack: isError(error) ? error.stack : 'No stack trace',
          time: new Date().toISOString(),
          requestInfo: {
            file: req.file ? req.file.originalname : "íŒŒì¼ ì—†ìŒ",
            style: style || "ìŠ¤íƒ€ì¼ ì—†ìŒ",
            hasSession: !!req.session,
            user: req.user ? `${req.user.username} (ID: ${req.user.id})` : "ë¡œê·¸ì¸ ì—†ìŒ"
          }
        });

        try {
          // ì›ë˜ íŒŒì¼ëª…ì—ì„œ í™•ì¥ìë¥¼ ì œì™¸í•œ ì´ë¦„ ì‚¬ìš©
          const nameWithoutExt = path.basename(req.file.originalname, path.extname(req.file.originalname));

          // ì´ë¯¸ì§€ ì €ì¥ì— ì‹¤íŒ¨í•˜ë”ë¼ë„ ì‚¬ìš©ìì—ê²Œ ì¹œìˆ™í•œ ì œëª© ìœ ì§€
          console.log("[ì´ë¯¸ì§€ ë³€í™˜] ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ì¹œìˆ™í•œ ì œëª©ìœ¼ë¡œ ì‘ë‹µ ìƒì„±");

          // ì´ë¯¸ì§€ URL ë³€í™˜ ìƒíƒœì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
          const imgUrl = transformedImageUrl && transformedImageUrl.includes("placehold.co")
            ? transformedImageUrl  // ì´ë¯¸ ì—ëŸ¬ ì´ë¯¸ì§€ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ì‚¬ìš©
            : `/api/placeholder?id=${dbSavedImage?.id || 'error'}&text=${encodeURIComponent("ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")}`;

          savedImage = {
            id: -1,
            title: `${style} ${nameWithoutExt}`, // "ì˜¤ë¥˜:" ì ‘ë‘ì‚¬ ì œê±°
            style,
            originalUrl: tempFilePath,
            transformedUrl: imgUrl,
            createdAt: new Date().toISOString(),
            isTemporary: true,
            // ë””ë²„ê¹… ì •ë³´ ì¶”ê°€ (í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” í‘œì‹œë˜ì§€ ì•ŠìŒ)
            debug: {
              errorOccurred: true,
              errorTime: new Date().toISOString(),
              errorType: isError(error) ? error.name : "UnknownError",
              errorMessage: getErrorMessage(error)
            }
          };

          console.log(`[ì´ë¯¸ì§€ ë³€í™˜] ì˜¤ë¥˜ ì‘ë‹µ ê°ì²´ ìƒì„± ì™„ë£Œ: ${savedImage.title}`);
        } catch (formatError) {
          console.error("[ì´ë¯¸ì§€ ë³€í™˜] ì˜¤ë¥˜ ì‘ë‹µ ìƒì„± ì¤‘ ì¶”ê°€ ì˜¤ë¥˜:", formatError);

          // ì™„ì „ ì‹¤íŒ¨ ì‹œ ìµœì†Œí•œì˜ ì •ë³´ë§Œ í¬í•¨í•œ ê¸°ë³¸ ì‘ë‹µ
          savedImage = {
            id: -1,
            title: `ì´ë¯¸ì§€ ${new Date().toLocaleTimeString()}`,
            style: style || "ê¸°ë³¸",
            originalUrl: "",
            transformedUrl: "/api/placeholder?error=true",
            createdAt: new Date().toISOString(),
            isTemporary: true
          };
        }
      }

      return res.status(201).json(savedImage);
    } catch (error) {
      console.error("Error transforming image:", error);
      return res.status(500).json({ error: "Failed to transform image" });
    }
  });



  // ğŸ–¼ï¸ ì´ë¯¸ì§€ ì¡°íšŒ API (ì¹´í…Œê³ ë¦¬ í•„í„°ë§ í¬í•¨)
  // ê´€ë¦¬ììš© ì „ì²´ ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ API
  app.get("/api/image", requireAuth, async (req, res) => {
    try {
      const userId = validateUserId(req, res);
      if (!userId) return;

      // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
      const user = await db.query.users.findFirst({
        where: eq(users.id, Number(userId))
      });

      if (!user || !['admin', 'superadmin'].includes(user.memberType || '')) {
        return res.status(403).json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤." });
      }

      // í˜ì´ì§€ë„¤ì´ì…˜ íŒŒë¼ë¯¸í„°
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 50; // ì¸ë„¤ì¼ì´ë¯€ë¡œ ë” ë§ì´
      const offset = (page - 1) * limit;

      console.log(`ğŸ” [ê´€ë¦¬ì] ì „ì²´ ì´ë¯¸ì§€ ì¡°íšŒ - í˜ì´ì§€: ${page}, í•œê³„: ${limit}`);

      // ì „ì²´ ì´ë¯¸ì§€ ê°œìˆ˜ ë¨¼ì € ì¡°íšŒ
      const totalImages = await db.query.images.findMany();
      const total = totalImages.length;
      const totalPages = Math.ceil(total / limit);

      // í˜ì´ì§€ë„¤ì´ì…˜ëœ ì´ë¯¸ì§€ ì¡°íšŒ (ëª¨ë“  ì‚¬ìš©ì)
      const allImages = await db.query.images.findMany({
        orderBy: desc(images.createdAt),
        limit: limit,
        offset: offset
      });

      // ê° ì´ë¯¸ì§€ì˜ ì‚¬ìš©ì ì •ë³´ë¥¼ ë³„ë„ë¡œ ì¡°íšŒ
      const imagesWithUsers = await Promise.all(
        allImages.map(async (image) => {
          let username = 'ìµëª…';
          let memberType = 'free';

          if (image.userId) {
            // userIdê°€ ìˆ«ìì¸ì§€ í™•ì¸í•˜ì—¬ ì‚¬ìš©ì ì¡°íšŒ
            const userIdAsNumber = parseInt(image.userId);
            if (!isNaN(userIdAsNumber)) {
              const user = await db.query.users.findFirst({
                where: eq(users.id, userIdAsNumber),
                columns: {
                  username: true,
                  memberType: true
                }
              });
              if (user) {
                username = user.username;
                memberType = user.memberType || 'free';
              }
            }
          }

          return {
            ...image,
            user: {
              username,
              memberType
            }
          };
        })
      );

      console.log(`âœ… [ê´€ë¦¬ì] ${imagesWithUsers.length}ê°œ ì´ë¯¸ì§€ ì¡°íšŒë¨ (ì „ì²´: ${total}ê°œ)`);

      // URL ë³€í™˜ í•¨ìˆ˜ - SignedURLì„ ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
      const convertToDirectUrl = (url: string): string => {
        if (!url) return url;
        try {
          if (url.includes('GoogleAccessId=') || url.includes('Signature=')) {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            if (pathname.includes('/createtree-upload/')) {
              const filePath = pathname.substring(pathname.indexOf('/createtree-upload/') + '/createtree-upload/'.length);
              return `https://storage.googleapis.com/createtree-upload/${filePath}`;
            }
          }
          return url;
        } catch (error) {
          return url;
        }
      };

      // ê´€ë¦¬ììš© ë°ì´í„° ë³€í™˜ (ì¸ë„¤ì¼ ìš°ì„ )
      const optimizedImages = imagesWithUsers.map(img => {
        // ì¸ë„¤ì¼ URL ìš°ì„  ì‚¬ìš©
        let displayUrl = "";

        if (img.thumbnailUrl) {
          const thumbUrl = generatePublicUrl(img.thumbnailUrl);
          displayUrl = thumbUrl ? convertToDirectUrl(thumbUrl) : img.thumbnailUrl;
        } else if (img.transformedUrl && !img.transformedUrl.startsWith('data:')) {
          const transformUrl = generatePublicUrl(img.transformedUrl);
          displayUrl = transformUrl ? convertToDirectUrl(transformUrl) : img.transformedUrl;
        } else if (img.originalUrl && !img.originalUrl.startsWith('data:')) {
          const origUrl = generatePublicUrl(img.originalUrl);
          displayUrl = origUrl ? convertToDirectUrl(origUrl) : img.originalUrl;
        } else {
          displayUrl = `/api/placeholder?id=${img.id}&text=Loading`;
        }

        // ê° URL í•„ë“œë„ ë³€í™˜ ì ìš©
        const thumbUrl = img.thumbnailUrl ? generatePublicUrl(img.thumbnailUrl) : '';
        const transformUrl = img.transformedUrl && !img.transformedUrl.startsWith('data:') ? generatePublicUrl(img.transformedUrl) : '';
        const origUrl = img.originalUrl ? generatePublicUrl(img.originalUrl) : '';

        return {
          id: img.id,
          title: img.title || `ì´ë¯¸ì§€ ${img.id}`,
          url: displayUrl, // ì¸ë„¤ì¼ ìš°ì„ 
          thumbnailUrl: thumbUrl ? convertToDirectUrl(thumbUrl) : "",
          transformedUrl: transformUrl ? convertToDirectUrl(transformUrl) : "",
          originalUrl: origUrl ? convertToDirectUrl(origUrl) : "",
          categoryId: img.categoryId,
          style: img.style,
          createdAt: img.createdAt,
          userId: img.userId,
          username: img.user?.username || 'ì•Œ ìˆ˜ ì—†ìŒ',
          userType: img.user?.memberType || 'free'
        };
      });

      res.json({
        images: optimizedImages,
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1
        }
      });

    } catch (error) {
      console.error("âŒ [ê´€ë¦¬ì] ì´ë¯¸ì§€ ì¡°íšŒ ì˜¤ë¥˜:", error);
      res.status(500).json({ error: "ì´ë¯¸ì§€ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
    }
  });

  app.get("/api/images", requireAuth, async (req, res) => {
    try {
      const userId = validateUserId(req, res);
      if (!userId) return;

      const category = req.query.category as string;
      console.log(`ğŸ” ì´ë¯¸ì§€ ì¡°íšŒ - ì‚¬ìš©ì: ${userId}, ì¹´í…Œê³ ë¦¬: ${category || 'ì „ì²´'}`);

      // í•„í„° ì¡°ê±´ ì„¤ì •
      const whereConditions = [eq(images.userId, String(userId))];

      // ì¹´í…Œê³ ë¦¬ í•„í„° ì ìš©
      if (category && category !== 'all') {
        whereConditions.push(eq(images.categoryId, category));
      }

      // DB ì¡°íšŒ (ì¹´í…Œê³ ë¦¬ í•„í„° í¬í•¨)
      const userImages = await db.query.images.findMany({
        where: and(...whereConditions),
        orderBy: desc(images.createdAt),
        limit: 50
      });

      console.log(`âœ… ${userImages.length}ê°œ ì´ë¯¸ì§€ ì¡°íšŒë¨ (ì¹´í…Œê³ ë¦¬: ${category || 'ì „ì²´'})`);

      // URL ë³€í™˜ í•¨ìˆ˜ - SignedURLì„ ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
      const convertToDirectUrl = (url: string): string => {
        if (!url) return url;
        try {
          // SignedURLì¸ ê²½ìš° ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
          if (url.includes('GoogleAccessId=') || url.includes('Signature=')) {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            if (pathname.includes('/createtree-upload/')) {
              const filePath = pathname.substring(pathname.indexOf('/createtree-upload/') + '/createtree-upload/'.length);
              return `https://storage.googleapis.com/createtree-upload/${filePath}`;
            }
          }
          // ì´ë¯¸ ì§ì ‘ URLì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
          return url;
        } catch (error) {
          return url;
        }
      };

      // ğŸ¯ í´ë¼ì´ì–¸íŠ¸ìš© ë°ì´í„° ë³€í™˜
      const optimizedImages = userImages.map(img => {
        // Base64 ë°ì´í„° ì œì™¸í•˜ê³  íŒŒì¼ ê²½ë¡œë§Œ ì‚¬ìš©
        let displayUrl = "";

        if (img.thumbnailUrl) {
          const thumbUrl = generatePublicUrl(img.thumbnailUrl);
          displayUrl = thumbUrl ? convertToDirectUrl(thumbUrl) : img.thumbnailUrl;
        } else if (img.transformedUrl && !img.transformedUrl.startsWith('data:')) {
          const transformUrl = generatePublicUrl(img.transformedUrl);
          displayUrl = transformUrl ? convertToDirectUrl(transformUrl) : img.transformedUrl;
        } else if (img.originalUrl && !img.originalUrl.startsWith('data:')) {
          const origUrl = generatePublicUrl(img.originalUrl);
          displayUrl = origUrl ? convertToDirectUrl(origUrl) : img.originalUrl;
        } else {
          // Base64ì¸ ê²½ìš° í”Œë ˆì´ìŠ¤í™€ë” ì‚¬ìš©
          displayUrl = `/api/placeholder?id=${img.id}&text=Loading`;
        }

        // ê° URL í•„ë“œë„ ë³€í™˜ ì ìš©
        const thumbUrl = img.thumbnailUrl ? generatePublicUrl(img.thumbnailUrl) : '';
        const transformUrl = img.transformedUrl && !img.transformedUrl.startsWith('data:') ? generatePublicUrl(img.transformedUrl) : '';
        const origUrl = img.originalUrl ? generatePublicUrl(img.originalUrl) : '';

        return {
          id: img.id,
          title: img.title || "",
          url: displayUrl,
          thumbnailUrl: thumbUrl ? convertToDirectUrl(thumbUrl) : "",
          transformedUrl: transformUrl ? convertToDirectUrl(transformUrl) : "",
          originalUrl: origUrl ? convertToDirectUrl(origUrl) : "",
          createdAt: img.createdAt?.toISOString() || "",
          categoryId: img.categoryId
        };
      });

      console.log(`ğŸš€ ì´ë¯¸ì§€ API ì™„ë£Œ`);

      res.json({ images: optimizedImages });

    } catch (error: any) {
      console.error(`âŒ ì´ë¯¸ì§€ API ì˜¤ë¥˜:`, error);
      res.status(500).json({ error: "ì„œë²„ ì˜¤ë¥˜" });
    }
  });

  // JWT ê¸°ë°˜ ìµœê·¼ ì´ë¯¸ì§€ ì¡°íšŒ API (ì‚¬ìš©ì ë©”ëª¨ë¦¬ ì»¬ë ‰ì…˜ìš©)
  app.get("/api/image/recent", requireAuth, async (req, res) => {
    try {
      // ìºì‹± ë°©ì§€ í—¤ë” ì¶”ê°€
      res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
      res.setHeader('Surrogate-Control', 'no-store');

      // JWTì—ì„œ ì¸ì¦ëœ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const userId = req.user!.userId;
      const username = req.user!.username;

      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;
      const category = req.query.category as string; // 'maternity', 'family', 'sticker'

      // JWT ì¸ì¦ í›„ í•­ìƒ í•´ë‹¹ ì‚¬ìš©ìì˜ ì´ë¯¸ì§€ë§Œ í•„í„°ë§
      console.log(`[ìµœê·¼ ì´ë¯¸ì§€ API] JWT ì¸ì¦ëœ ì‚¬ìš©ì ${username} (ID: ${userId})ì˜ ìµœê·¼ ì´ë¯¸ì§€ ì¡°íšŒ`);

      // ì—¬ëŸ¬ ê°œì˜ ì´ë¯¸ì§€ë¥¼ ì–»ê¸° ìœ„í•´ ì œí•œì„ ë†’ì„
      const dbLimit = Math.max(30, limit * 3); // ìµœì†Œ 30ê°œ ë˜ëŠ” ìš”ì²­í•œ limitì˜ 3ë°°

      console.log(`[ìµœê·¼ ì´ë¯¸ì§€ API] ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ${dbLimit}ê°œì˜ ì´ë¯¸ì§€ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘...`);

      // ì´ˆê³ ì† ì§ì ‘ DB ì¿¼ë¦¬ë¡œ êµì²´
      const dbImages = await db
        .select()
        .from(images)
        .where(eq(images.userId, String(userId)))
        .orderBy(desc(images.createdAt))
        .limit(dbLimit);

      // í•„í„°ë§ ì¡°ê±´ ì™„í™”: ìµœê·¼ 24ì‹œê°„ ë‚´ì˜ ì´ë¯¸ì§€ë„ í¬í•¨ (1ì‹œê°„â†’24ì‹œê°„)
      const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24ì‹œê°„ ì „ íƒ€ì„ìŠ¤íƒ¬í”„

      let recentImages = dbImages
        .filter(img => {
          // createdAtì´ 24ì‹œê°„ ì´ë‚´ì¸ ì´ë¯¸ì§€ í¬í•¨
          const createTime = new Date(img.createdAt);
          return createTime > dayAgo;
        })
        .slice(0, limit); // ìš”ì²­í•œ ì œí•œìœ¼ë¡œ ê²°ê³¼ ì œí•œ

      // ê²°ê³¼ ê°œìˆ˜ê°€ ë¶€ì¡±í•˜ë©´ ì‹œê°„ ì œí•œ ì—†ì´ ìµœê·¼ ì´ë¯¸ì§€ í¬í•¨
      if (recentImages.length < limit) {
        console.log(`[ìµœê·¼ ì´ë¯¸ì§€ API] 24ì‹œê°„ ì´ë‚´ ì´ë¯¸ì§€ê°€ ${recentImages.length}ê°œë¡œ ë¶€ì¡±í•©ë‹ˆë‹¤. ì‹œê°„ ì œí•œ ì—†ì´ ìµœê·¼ ì´ë¯¸ì§€ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.`);

        // ì´ë¯¸ í¬í•¨ëœ ì´ë¯¸ì§€ ID ì§‘í•©
        const existingIds = new Set(recentImages.map(img => img.id));

        // ì‹œê°„ ì œí•œ ì—†ì´ ì¶”ê°€ ì´ë¯¸ì§€ë¥¼ í¬í•¨
        const additionalImages = dbImages
          .filter(img => !existingIds.has(img.id)) // ì¤‘ë³µ ë°©ì§€
          .slice(0, limit - recentImages.length); // ë‚¨ì€ ì œí•œê¹Œì§€ë§Œ ì¶”ê°€

        // ê²°í•©
        recentImages = [...recentImages, ...additionalImages];
      }

      // ì¹´í…Œê³ ë¦¬ë³„ í•„í„°ë§ ì ìš©
      if (category) {
        const originalCount = recentImages.length;
        recentImages = recentImages.filter((image: any) => {
          const style = image.style?.toLowerCase() || '';
          const title = image.title?.toLowerCase() || '';

          switch (category) {
            case 'maternity':
              return style.includes('maternity') || style.includes('ë§Œì‚­') ||
                     title.includes('ë§Œì‚­') || style.includes('goddess') ||
                     style.includes('ethereal') || style.includes('vintage') ||
                     style.includes('_________') || title.includes('ì—¬ì‹ ');
            case 'family':
              return style.includes('family') || style.includes('ê°€ì¡±') ||
                     title.includes('ê°€ì¡±') || style.includes('modern_minimalist');
            case 'sticker':
              return style.includes('sticker') || style.includes('ìŠ¤í‹°ì»¤') ||
                     title.includes('ìŠ¤í‹°ì»¤') || style.includes('chibi') ||
                     style.includes('star') || style.includes('cute');
            default:
              return true;
          }
        });
        console.log(`[ìµœê·¼ ì´ë¯¸ì§€ API] ì¹´í…Œê³ ë¦¬ '${category}' í•„í„°ë§: ${originalCount}ê°œ â†’ ${recentImages.length}ê°œ`);
      }

      console.log(`[ìµœê·¼ ì´ë¯¸ì§€ API] ì „ì²´ ${dbImages.length}ê°œ ì¤‘ ${recentImages.length}ê°œ ì´ë¯¸ì§€ ë°˜í™˜ (ì‚¬ìš©ì: ${userId || 'None'})`);

      // URL ë³€í™˜ í•¨ìˆ˜ - SignedURLì„ ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
      const convertToDirectUrl = (url: string): string => {
        if (!url) return url;
        try {
          // SignedURLì¸ ê²½ìš° ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
          if (url.includes('GoogleAccessId=') || url.includes('Signature=')) {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            if (pathname.includes('/createtree-upload/')) {
              const filePath = pathname.substring(pathname.indexOf('/createtree-upload/') + '/createtree-upload/'.length);
              return `https://storage.googleapis.com/createtree-upload/${filePath}`;
            }
          }
          // ì´ë¯¸ ì§ì ‘ URLì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
          return url;
        } catch (error) {
          return url;
        }
      };

      // ì´ë¯¸ì§€ URL ë³€í™˜ ì ìš©
      const convertedImages = recentImages.map((img: any) => {
        const thumbUrl = img.thumbnailUrl ? generatePublicUrl(img.thumbnailUrl) : '';
        const transformUrl = img.transformedUrl ? generatePublicUrl(img.transformedUrl) : '';
        const origUrl = img.originalUrl ? generatePublicUrl(img.originalUrl) : '';

        return {
          ...img,
          thumbnailUrl: thumbUrl ? convertToDirectUrl(thumbUrl) : img.thumbnailUrl,
          transformedUrl: transformUrl ? convertToDirectUrl(transformUrl) : img.transformedUrl,
          originalUrl: origUrl ? convertToDirectUrl(origUrl) : img.originalUrl
        };
      });

      // ë””ë²„ê¹…: ê° ì´ë¯¸ì§€ì˜ ê¸°ë³¸ ì •ë³´ë¥¼ ë¡œê·¸ë¡œ ì¶œë ¥
      convertedImages.forEach((img: any, index: number) => {
        let metadataInfo = 'ì—†ìŒ';
        if (img.metadata) {
          try {
            const metadata = typeof img.metadata === 'string'
              ? JSON.parse(img.metadata)
              : img.metadata;
            metadataInfo = `userId: ${metadata.userId || 'ì—†ìŒ'}, isShared: ${metadata.isShared || false}`;
          } catch (e) {}
        }

        console.log(`[ìµœê·¼ ì´ë¯¸ì§€ ${index+1}/${convertedImages.length}] ID: ${img.id}, ì œëª©: ${img.title}, ìƒì„±ì¼: ${new Date(img.createdAt).toISOString()}, ë©”íƒ€ë°ì´í„°: ${metadataInfo}`);
      });

      return res.json(convertedImages);
    } catch (error) {
      console.error("Error fetching recent images:", error);
      return res.status(500).json({ error: "Failed to fetch recent images" });
    }
  });

  // ğŸ¯ ë§Œì‚­ì‚¬ì§„/ê°€ì¡±ì‚¬ì§„ ì´ë¯¸ì§€ ìƒì„± API (íŒŒì¼ ì—…ë¡œë“œ + ë³€ìˆ˜ ì§€ì›) - 3ë‹¨ê³„ ë³€í™˜ ì „ìš©
  app.post("/api/generate-image", requireAuth, requirePremiumAccess, requireActiveHospital(), (req, res, next) => {
    console.log("ğŸš€ [ì´ë¯¸ì§€ ìƒì„±] API í˜¸ì¶œ ì‹œì‘");
    console.log("- Content-Type:", req.headers['content-type']);
    console.log("- Authorization:", req.headers.authorization ? 'ì¡´ì¬í•¨' : 'ì—†ìŒ');

    upload.single("image")(req, res, (err) => {
      if (err) {
        console.error("âŒ [íŒŒì¼ ì—…ë¡œë“œ] Multer ì˜¤ë¥˜:", err.message);
        return res.status(400).json({
          success: false,
          message: err.message.includes('File too large')
            ? "íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. 10MB ì´í•˜ì˜ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”."
            : err.message
        });
      }
      next();
    });
  }, async (req, res) => {
    try {
      console.log("ğŸ“ [íŒŒì¼ í™•ì¸] ì—…ë¡œë“œëœ íŒŒì¼:", req.file ? req.file.filename : 'ì—†ìŒ');

      const { style, variables, model, categoryId = "mansak_img" } = req.body;

      if (!style) {
        console.log("âŒ [ì´ë¯¸ì§€ ìƒì„±] ìŠ¤íƒ€ì¼ì´ ì„ íƒë˜ì§€ ì•ŠìŒ");
        return res.status(400).json({ error: "ìŠ¤íƒ€ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”" });
      }

      console.log("ğŸ“ [ì´ë¯¸ì§€ ìƒì„±] ìš”ì²­ ì •ë³´:");
      console.log("- íŒŒì¼:", req.file ? req.file.filename : 'ì—†ìŒ');
      console.log("- ìŠ¤íƒ€ì¼:", style);
      console.log("- ë³€ìˆ˜:", variables);
      console.log("- ëª¨ë¸:", model);
      console.log("- ì¹´í…Œê³ ë¦¬:", categoryId);
      console.log("ğŸ“‹ [ë””ë²„ê¹…] ì „ì²´ req.body:", JSON.stringify(req.body, null, 2));

      // ì‚¬ìš©ì ID í™•ì¸ ë° ê²€ì¦
      const userId = validateUserId(req, res);
      if (!userId) return;

      // í•„ìš”í•œ ëª¨ë“ˆë“¤ì„ ë¨¼ì € import
      const pathModule = await import('path');
      const fsModule = await import('fs');
      const fetch = (await import('node-fetch')).default;
      const sharp = (await import('sharp')).default;
      const { v4: uuidv4 } = await import('uuid');

      // ë³€ìˆ˜ íŒŒì‹±
      let parsedVariables = {};
      if (variables) {
        try {
          parsedVariables = typeof variables === 'string' ? JSON.parse(variables) : variables;
          console.log("âœ… [ì´ë¯¸ì§€ ìƒì„±] ë³€ìˆ˜ íŒŒì‹± ì„±ê³µ:", parsedVariables);
        } catch (e) {
          console.log("âš ï¸ [ì´ë¯¸ì§€ ìƒì„±] ë³€ìˆ˜ íŒŒì‹± ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©");
        }
      }

      // ğŸ¨ ì»¨ì…‰ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±
      let prompt = "A beautiful portrait with professional lighting and artistic styling";
      let systemPrompt: string | null = null;
      let finalModel: string; // ğŸ”¥ í•¨ìˆ˜ ë ˆë²¨ì—ì„œ finalModel ì„ ì–¸

      // ì»¨ì…‰ ì •ë³´ ì¡°íšŒ
      console.log(`ğŸ” [ì»¨ì…‰ ì¡°íšŒ] ${style} ì»¨ì…‰ ê²€ìƒ‰ ì¤‘...`);

      const concept = await db.query.concepts.findFirst({
        where: eq(concepts.conceptId, style)
      });

      if (concept) {
        console.log(`ğŸ“‹ [ì»¨ì…‰ ë°œê²¬] ${style} ì»¨ì…‰ ì •ë³´:`, {
          title: concept.title,
          hasSystemPrompt: !!(concept.systemPrompt && concept.systemPrompt.trim()),
          hasPromptTemplate: !!(concept.promptTemplate && concept.promptTemplate.trim()),
          availableModels: concept.availableModels
        });

        // ğŸ”’ ìš”ì²­ëœ ëª¨ë¸ ê²€ì¦ (ì˜ëª»ëœ ëª¨ë¸ ìš”ì²­ ì‹œ 400 ì—ëŸ¬ ë°˜í™˜)
        const modelValidation = await validateRequestedModel(model, concept.availableModels as string[] | null | undefined);
        if (!modelValidation.isValid && modelValidation.error) {
          console.log(`âŒ [ëª¨ë¸ ê²€ì¦ ì‹¤íŒ¨] ${modelValidation.error.requestedModel}ëŠ” ì§€ì›ë˜ì§€ ì•ŠëŠ” ëª¨ë¸ì…ë‹ˆë‹¤`);
          return res.status(400).json({
            error: modelValidation.error.message,
            requestedModel: modelValidation.error.requestedModel,
            allowedModels: modelValidation.error.allowedModels
          });
        }

        // ğŸ”’ AI ëª¨ë¸ ê²°ì • (ìš”ì²­ ëª¨ë¸ â†’ ì»¨ì…‰ ì œí•œ â†’ ì‹œìŠ¤í…œ ê¸°ë³¸ê°’)
        finalModel = await resolveAiModel(model, concept.availableModels as string[] | null | undefined);
        console.log(`âœ… [AI ëª¨ë¸ ê²°ì •] ìµœì¢… ì„ íƒëœ ëª¨ë¸: ${finalModel} (ìš”ì²­: ${model || 'none'})`);

        // systemPromptê°€ ìˆìœ¼ë©´ systemPromptë¥¼ ì‚¬ìš©í•˜ê³ , promptTemplateëŠ” ìµœì¢… í”„ë¡¬í”„íŠ¸ë¡œ ì‚¬ìš©
        if (concept.systemPrompt && concept.systemPrompt.trim() !== '') {
          console.log(`ğŸ¯ [ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸] ì ìš©:`, concept.systemPrompt.substring(0, 100) + "...");
          systemPrompt = concept.systemPrompt;

          // ê³µí†µ ë³€ìˆ˜ ì¹˜í™˜ í•¨ìˆ˜ ì‚¬ìš© (ê¸°ì¡´ {var}ì™€ ìƒˆë¡œìš´ {{var}} í˜•ì‹ ëª¨ë‘ ì§€ì›)
          if (parsedVariables && Object.keys(parsedVariables).length > 0) {
            console.log(`ğŸ”„ [ë³€ìˆ˜ ì¹˜í™˜] ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ë³€ìˆ˜ ì ìš© ì¤‘...`);
            systemPrompt = applyTemplateVariables(systemPrompt, parsedVariables);
          }
        }

        // ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì ìš©
        if (concept.promptTemplate && concept.promptTemplate.trim() !== '') {
          console.log(`ğŸ¯ [í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿] ì ìš©:`, concept.promptTemplate.substring(0, 100) + "...");
          prompt = concept.promptTemplate;

          // ê³µí†µ ë³€ìˆ˜ ì¹˜í™˜ í•¨ìˆ˜ ì‚¬ìš© (ê¸°ì¡´ {var}ì™€ ìƒˆë¡œìš´ {{var}} í˜•ì‹ ëª¨ë‘ ì§€ì›)
          if (parsedVariables && Object.keys(parsedVariables).length > 0) {
            console.log(`ğŸ”„ [ë³€ìˆ˜ ì¹˜í™˜] í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ì— ë³€ìˆ˜ ì ìš© ì¤‘...`);
            prompt = applyTemplateVariables(prompt, parsedVariables);
          }
        }
      } else {
        console.log(`âŒ [ì»¨ì…‰ ë¯¸ë°œê²¬] ${style} ì»¨ì…‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        // ğŸ”¥ ì»¨ì…‰ì´ ì—†ì„ ë•ŒëŠ” ìš”ì²­ëœ ëª¨ë¸ì´ë‚˜ ê¸°ë³¸ê°’ ì‚¬ìš©
        finalModel = await resolveAiModel(model, null);
        console.log(`âœ… [AI ëª¨ë¸ ê²°ì •] ê¸°ë³¸ ëª¨ë¸ ì‚¬ìš©: ${finalModel} (ìš”ì²­: ${model || 'none'})`);
      }

      console.log("ğŸ¨ [ì´ë¯¸ì§€ ìƒì„±] ìµœì¢… í”„ë¡¬í”„íŠ¸:", prompt);
      if (systemPrompt) {
        console.log("ğŸ”§ [ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸] ì „ë‹¬ë¨:", systemPrompt.substring(0, 100) + "...");
      }

      // íŒŒì¼ ë²„í¼ ì²˜ë¦¬ - ë©”ëª¨ë¦¬ ì €ì¥ ë°©ì‹ ì§€ì›
      let imageBuffer: Buffer;

      // req.file ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (í…ìŠ¤íŠ¸ ì „ìš© ì´ë¯¸ì§€ ìƒì„±ì€ íŒŒì¼ ì—†ì´ë„ ê°€ëŠ¥)
      const isTextOnlyGeneration = !req.file;
      console.log(`ğŸ“ [ì´ë¯¸ì§€ ìƒì„± ëª¨ë“œ] ${isTextOnlyGeneration ? 'í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±' : 'ì´ë¯¸ì§€ ë³€í™˜'}`);
      
      if (isTextOnlyGeneration && finalModel === "gemini") {
        console.error("âŒ [Gemini ì œí•œ] GeminiëŠ” í…ìŠ¤íŠ¸â†’ì´ë¯¸ì§€ ìƒì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤");
        return res.status(400).json({
          success: false,
          message: "Gemini ëª¨ë¸ì€ í…ìŠ¤íŠ¸ ì „ìš© ì´ë¯¸ì§€ ìƒì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. OpenAI ëª¨ë¸ì„ ì„ íƒí•´ì£¼ì„¸ìš”."
        });
      }

      // íŒŒì¼ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ íŒŒì¼ ì²˜ë¦¬ ì‹¤í–‰
      if (req.file) {
        if (req.file.buffer && req.file.buffer.length > 0) {
          // ë©”ëª¨ë¦¬ ì €ì¥ ë°©ì‹
          imageBuffer = req.file.buffer;
          console.log("ğŸ“ ë©”ëª¨ë¦¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');
        } else if (req.file.path) {
          // ë””ìŠ¤í¬ ì €ì¥ ë°©ì‹ - íŒŒì¼ ê²½ë¡œì—ì„œ ì½ê¸°
          try {
            imageBuffer = await fs.promises.readFile(req.file.path);
            console.log("ğŸ“ ë””ìŠ¤í¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');
          } finally {
            // íŒŒì¼ ì½ê¸° ì„±ê³µ/ì‹¤íŒ¨ì™€ ê´€ê³„ì—†ì´ ì„ì‹œ íŒŒì¼ ì‚­ì œ
            try {
              await fs.promises.unlink(req.file.path);
            } catch (unlinkError) {
              console.warn("âš ï¸ ì„ì‹œ íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨:", unlinkError);
            }
          }
        } else {
          console.error("âŒ íŒŒì¼ ë²„í¼ì™€ ê²½ë¡œ ëª¨ë‘ ì—†ìŒ");
          return res.status(500).json({
            success: false,
            message: "ì—…ë¡œë“œëœ íŒŒì¼ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
          });
        }
      } else {
        console.log("ğŸ“ [í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±] íŒŒì¼ ì—†ì´ í…ìŠ¤íŠ¸ë¡œë§Œ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤");
      }

      // ğŸ”¥ ëª¨ë¸ì— ë”°ë¥¸ ì´ë¯¸ì§€ ìƒì„±/ë³€í™˜ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
      let transformedImageUrl: string;
      let downloadedImageBuffer: Buffer | undefined;
      let isTextOnlyHttpUrl = false;

      if (isTextOnlyGeneration) {
        // í…ìŠ¤íŠ¸ ì „ìš© ì´ë¯¸ì§€ ìƒì„± (OpenAIë§Œ ì§€ì›)
        console.log("ğŸ”¥ [í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±] OpenAI í…ìŠ¤íŠ¸â†’ì´ë¯¸ì§€ ìƒì„± ì‹œì‘");
        const openaiService = await import('./services/openai');
        
        // ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì™€ í”„ë¡¬í”„íŠ¸ë¥¼ ê²°í•©
        const finalPrompt = systemPrompt 
          ? `${systemPrompt}\n\n${prompt}`
          : prompt;
        
        const imageResult = await openaiService.generateImageWithDALLE(finalPrompt);
        console.log("âœ… [í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±] OpenAI ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ:", imageResult?.substring(0, 100) + "...");
        
        // ì´ë¯¸ì§€ ë°ì´í„° ì²˜ë¦¬ (OpenAIëŠ” URL ë°˜í™˜)
        if (imageResult && !imageResult.includes('placehold.co')) {
          // OpenAIëŠ” URLì„ ë°˜í™˜í•˜ë¯€ë¡œ ì €ì¥ìš© í”Œë˜ê·¸ ì„¤ì •
          console.log("ğŸŒ [í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±] OpenAI URL ë°˜í™˜, saveImageFromUrlToGCS ì‚¬ìš©");
          transformedImageUrl = imageResult;
          isTextOnlyHttpUrl = true;
        } else {
          console.error("ğŸš¨ [í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±] ì´ë¯¸ì§€ ë°ì´í„° ì²˜ë¦¬ ì‹¤íŒ¨");
          transformedImageUrl = imageResult; // fallback URL
        }
      } else {
        // ê¸°ì¡´ ì´ë¯¸ì§€ ë³€í™˜ í”„ë¡œì„¸ìŠ¤
        if (finalModel === "gemini") {
          // Gemini 2.5 Flash Image Preview ì‚¬ìš©
          console.log("ğŸš€ [ì´ë¯¸ì§€ ë³€í™˜] Gemini 2.5 Flash í”„ë¡œì„¸ìŠ¤ ì‹œì‘");
          const geminiService = await import('./services/gemini');
          transformedImageUrl = await geminiService.transformWithGemini(
            prompt,
            normalizeOptionalString(systemPrompt),
            imageBuffer!,
            parsedVariables
          );
          console.log("âœ… [ì´ë¯¸ì§€ ë³€í™˜] Gemini 2.5 ë³€í™˜ ê²°ê³¼:", transformedImageUrl);
        } else {
          // ê¸°ë³¸ê°’: OpenAI 3ë‹¨ê³„ ë³€í™˜ í”„ë¡œì„¸ìŠ¤ (GPT-4V + GPT-4o + gpt-image-1)
          console.log("ğŸ”¥ [ì´ë¯¸ì§€ ë³€í™˜] OpenAI 3ë‹¨ê³„ ë³€í™˜ í”„ë¡œì„¸ìŠ¤ ì‹œì‘");
          const openaiService = await import('./services/openai-dalle3');
          transformedImageUrl = await openaiService.transformWithOpenAI(
            prompt,
            imageBuffer!,
            normalizeOptionalString(systemPrompt),
            parsedVariables
          );
          console.log("âœ… [ì´ë¯¸ì§€ ë³€í™˜] OpenAI 3ë‹¨ê³„ ë³€í™˜ ê²°ê³¼:", transformedImageUrl);
        }
      }

      if (!transformedImageUrl || transformedImageUrl.includes('placehold.co')) {
        console.error("ğŸš¨ ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨");
        return res.status(500).json({
          success: false,
          message: "ì´ë¯¸ì§€ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
        });
      }

      // ğŸ”½ ì´ë¯¸ì§€ ì²˜ë¦¬ (ëª¨ë¸ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬)
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const datePath = `${year}/${month}/${day}`;

      let savedImageUrl: string;
      let savedThumbnailUrl: string;

      // userIdëŠ” ì´ë¯¸ 2875ì¤„ì—ì„œ ê²€ì¦ë˜ì—ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” Stringìœ¼ë¡œë§Œ ë³€í™˜
      const userIdString = String(userId);

      if (isTextOnlyGeneration && transformedImageUrl === "text_only_generation_success") {
        // í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±: downloadedImageBufferê°€ ì´ë¯¸ ì„¤ì •ë¨
        console.log("ğŸ¯ [í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±] ì´ë¯¸ì§€ Buffer ì²˜ë¦¬ ì‹œì‘");
        
        // UUID íŒŒì¼ëª… ìƒì„±
        const uuid = uuidv4();
        const filename = `${uuid}.webp`;

        // GCSì— ì§ì ‘ ì—…ë¡œë“œ
        const gcsResult = await saveImageToGCS(downloadedImageBuffer!, userIdString, categoryId, filename);
        savedImageUrl = gcsResult.originalUrl;
        savedThumbnailUrl = gcsResult.thumbnailUrl;
        
        console.log("âœ… [í…ìŠ¤íŠ¸ ì „ìš© ìƒì„±] GCS ì—…ë¡œë“œ ì™„ë£Œ:", savedImageUrl);
      } else if (finalModel?.toLowerCase() === "gemini" && transformedImageUrl.startsWith('/uploads/')) {
        // GeminiëŠ” ì´ë¯¸ ë¡œì»¬ì— ì €ì¥ë˜ì–´ ìˆìŒ
        console.log("âœ… [Gemini] ë¡œì»¬ ì´ë¯¸ì§€ ê²½ë¡œ ì‚¬ìš©:", transformedImageUrl);

        // íŒŒì¼ ê²½ë¡œì—ì„œ ì½ê¸°
        const localPath = pathModule.join(process.cwd(), transformedImageUrl.substring(1));
        downloadedImageBuffer = await fsModule.promises.readFile(localPath);

        // UUID íŒŒì¼ëª… ìƒì„±
        const uuid = uuidv4();
        const filename = `${uuid}.webp`;

        // GCSì— ì—…ë¡œë“œ
        const gcsResult = await saveImageToGCS(downloadedImageBuffer, userIdString, categoryId, filename);
        savedImageUrl = gcsResult.originalUrl;
        savedThumbnailUrl = gcsResult.thumbnailUrl;
      } else {
        // OpenAIëŠ” ì›ê²© URLì—ì„œ ë‹¤ìš´ë¡œë“œ
        console.log("ğŸ”½ [OpenAI] ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹œì‘:", transformedImageUrl);

        // UUID íŒŒì¼ëª… ìƒì„±
        const uuid = uuidv4();
        const filename = `${uuid}.webp`;
        const thumbnailFilename = `${uuid}_thumb.webp`;

        // ë””ë ‰í† ë¦¬ ê²½ë¡œ ì„¤ì •
        const fullDir = pathModule.join(process.cwd(), 'uploads', 'full', datePath);
        const thumbnailDir = pathModule.join(process.cwd(), 'uploads', 'thumbnails', datePath);

        // ë””ë ‰í† ë¦¬ ìƒì„±
        await fsModule.promises.mkdir(fullDir, { recursive: true });
        await fsModule.promises.mkdir(thumbnailDir, { recursive: true });

        // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë° ì €ì¥
        const imageResponse = await fetch(transformedImageUrl);
        downloadedImageBuffer = Buffer.from(await imageResponse.arrayBuffer());

        // Full ì´ë¯¸ì§€ ì €ì¥
        const fullPath = pathModule.join(fullDir, filename);
        await sharp(downloadedImageBuffer)
          .webp({ quality: 85 })
          .toFile(fullPath);

        // ì¸ë„¤ì¼ ìƒì„± ë° ì €ì¥
        const thumbnailPath = pathModule.join(thumbnailDir, thumbnailFilename);
        // ì‘ì—…ì§€ì‹œì„œ: GCSì— ì§ì ‘ ì—…ë¡œë“œ, ë¡œì»¬ ì €ì¥ ì œê±°
        const thumbnailBuffer = await sharp(downloadedImageBuffer)
          .resize(300, 300, { fit: 'cover' })
          .webp({ quality: 75 })
          .toBuffer();

        // GCSì— ì§ì ‘ ì—…ë¡œë“œí•˜ê³  GCS URL ì €ì¥ (ì‹¤ì œ ì‚¬ìš©ì ID ì‚¬ìš©)
        const gcsResult = await saveImageToGCS(downloadedImageBuffer, userId, categoryId, filename);
        savedImageUrl = gcsResult.originalUrl;
        savedThumbnailUrl = gcsResult.thumbnailUrl;
      }

      console.log("âœ… [GCS ì—…ë¡œë“œ] ì™„ë£Œ:", savedImageUrl);

      // ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ì— ì´ë¯¸ì§€ ì €ì¥ (GCS URL ì‚¬ìš©)
      const [savedImage] = await db.insert(images).values({
        title: `ìƒì„±ëœ ì´ë¯¸ì§€ - ${style}`,
        style: style,
        originalUrl: savedImageUrl, // GCS ì›ë³¸ ì´ë¯¸ì§€ URL
        transformedUrl: savedImageUrl,
        thumbnailUrl: savedThumbnailUrl,
        userId: String(userId),
        categoryId: categoryId,
        conceptId: style,
        metadata: JSON.stringify({
          prompt,
          variables: parsedVariables,
          categoryId: categoryId,
          conceptId: style,
          model: finalModel
        })
      }).returning();

      console.log("âœ… [ì´ë¯¸ì§€ ì €ì¥] DB ì €ì¥ ì™„ë£Œ (GCS URL):", savedImage.id);

      return res.json({
        success: true,
        message: "ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
        image: {
          id: savedImage.id,
          title: savedImage.title,
          style: savedImage.style,
          originalUrl: savedImage.originalUrl,
          transformedUrl: savedImage.transformedUrl,
          thumbnailUrl: savedImage.thumbnailUrl,
          isTemporary: false,
          dbImageId: savedImage.id
        }
      });

    } catch (error) {
      console.error("âŒ [ì´ë¯¸ì§€ ìƒì„±] ì „ì²´ ì—ëŸ¬:", error);
      return res.status(500).json({
        error: "ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // ğŸ  ê°€ì¡±ì‚¬ì§„ ì´ë¯¸ì§€ ìƒì„± API (ë‹¤ì¤‘ ëª¨ë¸ ì§€ì›)
  app.post("/api/generate-family", requireAuth, requirePremiumAccess, requireActiveHospital(), upload.single("image"), async (req, res) => {
    console.log("ğŸš€ [ê°€ì¡±ì‚¬ì§„ ìƒì„±] API í˜¸ì¶œ ì‹œì‘");

    try {
      if (!req.file) {
        console.log("âŒ [ê°€ì¡±ì‚¬ì§„ ìƒì„±] íŒŒì¼ì´ ì—…ë¡œë“œë˜ì§€ ì•ŠìŒ");
        return res.status(400).json({ error: "ì´ë¯¸ì§€ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”" });
      }

      // ğŸ” ìš”ì²­ íŒŒë¼ë¯¸í„° ê²€ì¦
      const requestBodySchema = z.object({
        style: z.string().min(1, "ìŠ¤íƒ€ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”"),
        variables: z.union([z.string(), z.object({}).passthrough()]).optional(),
        model: z.string().optional()
      });

      let parsedBody;
      try {
        parsedBody = requestBodySchema.parse(req.body);
      } catch (validationError) {
        if (validationError instanceof z.ZodError) {
          console.log("âŒ [ê°€ì¡±ì‚¬ì§„ ìƒì„±] íŒŒë¼ë¯¸í„° ê²€ì¦ ì‹¤íŒ¨:", validationError.errors);
          return res.status(400).json({
            error: "ìš”ì²­ íŒŒë¼ë¯¸í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤",
            details: validationError.errors
          });
        }
        throw validationError;
      }

      const { style, variables, model } = parsedBody;

      // ğŸ“‹ variables íŒŒì‹± ì²˜ë¦¬
      let parsedVariables: Record<string, any> = {};
      if (variables) {
        try {
          if (typeof variables === "string") {
            parsedVariables = JSON.parse(variables);
          } else if (typeof variables === "object") {
            parsedVariables = variables;
          }
        } catch (error) {
          console.warn("âš ï¸ variables íŒŒì‹± ì‹¤íŒ¨:", error);
        }
      }

      // ğŸ¨ ì»¨ì…‰ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±
      let prompt = "A beautiful family portrait with professional lighting and artistic styling";
      let systemPrompt: string | null = null;
      let finalModel: string; // ğŸ”¥ í•¨ìˆ˜ ë ˆë²¨ì—ì„œ finalModel ì„ ì–¸

      // ì»¨ì…‰ ì •ë³´ ì¡°íšŒ
      console.log(`ğŸ” [ì»¨ì…‰ ì¡°íšŒ] ${style} ì»¨ì…‰ ê²€ìƒ‰ ì¤‘...`);

      const concept = await db.query.concepts.findFirst({
        where: eq(concepts.conceptId, style)
      });

      if (concept) {
        console.log(`ğŸ“‹ [ì»¨ì…‰ ë°œê²¬] ${style} ì»¨ì…‰ ì •ë³´:`, {
          title: concept.title,
          availableModels: concept.availableModels
        });

        // ğŸ”’ ìš”ì²­ëœ ëª¨ë¸ ê²€ì¦ (ì˜ëª»ëœ ëª¨ë¸ ìš”ì²­ ì‹œ 400 ì—ëŸ¬ ë°˜í™˜)
        const modelValidation = await validateRequestedModel(model, concept.availableModels as string[] | null | undefined);
        if (!modelValidation.isValid && modelValidation.error) {
          console.log(`âŒ [ëª¨ë¸ ê²€ì¦ ì‹¤íŒ¨] ${modelValidation.error.requestedModel}ëŠ” ì§€ì›ë˜ì§€ ì•ŠëŠ” ëª¨ë¸ì…ë‹ˆë‹¤`);
          return res.status(400).json({
            error: modelValidation.error.message,
            requestedModel: modelValidation.error.requestedModel,
            allowedModels: modelValidation.error.allowedModels
          });
        }

        // ğŸ”’ AI ëª¨ë¸ ê²°ì • (ìš”ì²­ ëª¨ë¸ â†’ ì»¨ì…‰ ì œí•œ â†’ ì‹œìŠ¤í…œ ê¸°ë³¸ê°’)
        finalModel = await resolveAiModel(model, concept.availableModels as string[] | null | undefined);
        console.log(`âœ… [AI ëª¨ë¸ ê²°ì •] ìµœì¢… ì„ íƒëœ ëª¨ë¸: ${finalModel} (ìš”ì²­: ${model || 'none'})`);

        // systemPromptê°€ ìˆìœ¼ë©´ systemPromptë¥¼ ì‚¬ìš©í•˜ê³ , promptTemplateëŠ” ìµœì¢… í”„ë¡¬í”„íŠ¸ë¡œ ì‚¬ìš©
        if (concept.systemPrompt && concept.systemPrompt.trim() !== '') {
          systemPrompt = concept.systemPrompt;
          console.log(`ğŸ”§ [ì‹œìŠ¤í…œí”„ë¡¬í”„íŠ¸] ${style} ì»¨ì…‰ ì‹œìŠ¤í…œí”„ë¡¬í”„íŠ¸ ì‚¬ìš©:`, systemPrompt.substring(0, 100) + "...");
        }

        if (concept.promptTemplate && concept.promptTemplate.trim() !== '') {
          prompt = concept.promptTemplate;
          console.log(`ğŸ¯ [í”„ë¡¬í”„íŠ¸í…œí”Œë¦¿] ${style} ì»¨ì…‰ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì‚¬ìš©:`, prompt);

          // ê³µí†µ ë³€ìˆ˜ ì¹˜í™˜ í•¨ìˆ˜ ì‚¬ìš© (ê¸°ì¡´ {var}ì™€ ìƒˆë¡œìš´ {{var}} í˜•ì‹ ëª¨ë‘ ì§€ì›)
          if (parsedVariables && Object.keys(parsedVariables).length > 0) {
            console.log(`ğŸ”„ [ë³€ìˆ˜ ì¹˜í™˜] í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ì— ë³€ìˆ˜ ì ìš© ì¤‘...`);
            prompt = applyTemplateVariables(prompt, parsedVariables);
          }
        }
      } else {
        console.log(`âŒ [ì»¨ì…‰ ë¯¸ë°œê²¬] ${style} ì»¨ì…‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        // ğŸ”¥ ì»¨ì…‰ì´ ì—†ì„ ë•ŒëŠ” ìš”ì²­ëœ ëª¨ë¸ì´ë‚˜ ê¸°ë³¸ê°’ ì‚¬ìš©
        finalModel = await resolveAiModel(model, null);
        console.log(`âœ… [AI ëª¨ë¸ ê²°ì •] ê¸°ë³¸ ëª¨ë¸ ì‚¬ìš©: ${finalModel} (ìš”ì²­: ${model || 'none'})`);
      }

      console.log("ğŸ¨ [ê°€ì¡±ì‚¬ì§„ ìƒì„±] ìµœì¢… í”„ë¡¬í”„íŠ¸:", prompt);
      if (systemPrompt) {
        console.log("ğŸ”§ [ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸] ì „ë‹¬ë¨:", systemPrompt.substring(0, 100) + "...");
      }

      // íŒŒì¼ ë²„í¼ ì²˜ë¦¬ - ë©”ëª¨ë¦¬ ì €ì¥ ë°©ì‹ ì§€ì›
      let imageBuffer: Buffer;

      if (req.file.buffer && req.file.buffer.length > 0) {
        // ë©”ëª¨ë¦¬ ì €ì¥ ë°©ì‹
        imageBuffer = req.file.buffer;
        console.log("ğŸ“ ë©”ëª¨ë¦¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');
      } else if (req.file.path) {
        // ë””ìŠ¤í¬ ì €ì¥ ë°©ì‹ - íŒŒì¼ ê²½ë¡œì—ì„œ ì½ê¸°
        try {
          imageBuffer = await fs.promises.readFile(req.file.path);
          console.log("ğŸ“ ë””ìŠ¤í¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');
        } finally {
          // íŒŒì¼ ì½ê¸° ì„±ê³µ/ì‹¤íŒ¨ì™€ ê´€ê³„ì—†ì´ ì„ì‹œ íŒŒì¼ ì‚­ì œ
          try {
            await fs.promises.unlink(req.file.path);
          } catch (unlinkError) {
            console.warn("âš ï¸ ì„ì‹œ íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨:", unlinkError);
          }
        }
      } else {
        console.error("âŒ íŒŒì¼ ë²„í¼ì™€ ê²½ë¡œ ëª¨ë‘ ì—†ìŒ");
        return res.status(500).json({
          success: false,
          message: "ì—…ë¡œë“œëœ íŒŒì¼ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        });
      }

      // ğŸ”¥ ëª¨ë¸ì— ë”°ë¥¸ ì´ë¯¸ì§€ ë³€í™˜ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
      let transformedImageUrl: string;

      if (finalModel === "gemini") {
        // Gemini 2.5 Flash Image Preview ì‚¬ìš©
        console.log("ğŸš€ [ê°€ì¡±ì‚¬ì§„ ìƒì„±] Gemini 2.5 Flash í”„ë¡œì„¸ìŠ¤ ì‹œì‘");
        const geminiService = await import('./services/gemini');
        transformedImageUrl = await geminiService.transformWithGemini(
          prompt,
          normalizeOptionalString(systemPrompt),
          imageBuffer
        );
        console.log("âœ… [ê°€ì¡±ì‚¬ì§„ ìƒì„±] Gemini 2.5 ë³€í™˜ ê²°ê³¼:", transformedImageUrl);
      } else {
        // ê¸°ë³¸ê°’: OpenAI 3ë‹¨ê³„ ë³€í™˜ í”„ë¡œì„¸ìŠ¤ (GPT-4V + GPT-4o + gpt-image-1)
        console.log("ğŸ”¥ [ê°€ì¡±ì‚¬ì§„ ìƒì„±] OpenAI 3ë‹¨ê³„ ë³€í™˜ í”„ë¡œì„¸ìŠ¤ ì‹œì‘");
        const openaiService = await import('./services/openai-dalle3');
        transformedImageUrl = await openaiService.transformWithOpenAI(
          prompt,
          imageBuffer,
          normalizeOptionalString(systemPrompt),
          parsedVariables
        );
        console.log("âœ… [ê°€ì¡±ì‚¬ì§„ ìƒì„±] OpenAI 3ë‹¨ê³„ ë³€í™˜ ê²°ê³¼:", transformedImageUrl);
      }

      if (!transformedImageUrl || transformedImageUrl.includes('placehold.co')) {
        console.error("ğŸš¨ ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨");
        return res.status(500).json({
          success: false,
          message: "ì´ë¯¸ì§€ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
        });
      }

      // ğŸ”½ ì´ë¯¸ì§€ ì²˜ë¦¬ (ëª¨ë¸ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬)
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const datePath = `${year}/${month}/${day}`;

      let downloadedImageBuffer: Buffer;
      let savedImageUrl: string;
      let savedThumbnailUrl: string;
      let gcsResult: any; // GCS ê²°ê³¼ ì €ì¥ìš© (ì „ì—­ ì„ ì–¸)

      // ì‚¬ìš©ì ID í•œ ë²ˆë§Œ ê²€ì¦ (ì¤‘ë³µ ì œê±°)
      const uid2 = validateUserId(req, res);
      if (!uid2) return;
      const familyUserId = String(uid2);

      if (finalModel?.toLowerCase() === "gemini" && transformedImageUrl.startsWith('/uploads/')) {
        // GeminiëŠ” ì´ë¯¸ ë¡œì»¬ì— ì €ì¥ë˜ì–´ ìˆìŒ
        console.log("âœ… [Gemini] ë¡œì»¬ ì´ë¯¸ì§€ ê²½ë¡œ ì‚¬ìš©:", transformedImageUrl);

        // íŒŒì¼ ê²½ë¡œì—ì„œ ì½ê¸°
        const normalizedPath = transformedImageUrl.startsWith('/')
          ? transformedImageUrl.substring(1)
          : transformedImageUrl;
        const localFilePath = path.join(process.cwd(), normalizedPath);

        // ë¹„ë™ê¸° íŒŒì¼ ì½ê¸° (ì´ë²¤íŠ¸ ë£¨í”„ ì°¨ë‹¨ ë°©ì§€)
        downloadedImageBuffer = await fs.promises.readFile(localFilePath);

        // GCSì— ì—…ë¡œë“œ
        const uuid = Math.random().toString(36).substring(2) + Date.now().toString(36);
        const filename = `${uuid}.webp`;

        // GCSì— ì—…ë¡œë“œ (ì‹¤ì œ ì‚¬ìš©ì ID ì‚¬ìš©)
        gcsResult = await saveImageToGCS(
          downloadedImageBuffer,
          familyUserId,
          'family_img',
          `family_${style}_generated`
        );
        savedImageUrl = gcsResult.originalUrl;
        savedThumbnailUrl = gcsResult.thumbnailUrl;
      } else {
        // OpenAI: URLì—ì„œ ë‹¤ìš´ë¡œë“œ í›„ GCS ì—…ë¡œë“œ (ìŠ¤í‹°ì»¤ì™€ ë™ì¼í•œ ë°©ì‹)
        console.log("ğŸŒ [OpenAI] URLì—ì„œ GCS ì—…ë¡œë“œ:", transformedImageUrl);

        gcsResult = await saveImageFromUrlToGCS(
          transformedImageUrl,
          familyUserId,
          'family_img',
          `family_${style}_generated`
        );
        savedImageUrl = gcsResult.originalUrl;
        savedThumbnailUrl = gcsResult.thumbnailUrl;
      }

      console.log("âœ… [ê°€ì¡±ì‚¬ì§„ GCS ì—…ë¡œë“œ] ì™„ë£Œ:", savedImageUrl);

      // ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ì— ì´ë¯¸ì§€ ì €ì¥
      // ì‚¬ìš©ì IDëŠ” ì´ë¯¸ ìœ„ì—ì„œ ê²€ì¦ë¨ (ì¤‘ë³µ ì œê±°)

      const [savedImage] = await db.insert(images).values({
        title: `family_${style}_generated`,
        transformedUrl: savedImageUrl,
        originalUrl: savedImageUrl, // GCS ì›ë³¸ ì´ë¯¸ì§€ URL (ë¡œì»¬ ê²½ë¡œ ì œê±°)
        thumbnailUrl: savedThumbnailUrl,
        userId: familyUserId,
        categoryId: "family_img",
        conceptId: style,
        metadata: JSON.stringify({
          prompt,
          variables: parsedVariables,
          categoryId: "family_img",
          conceptId: style,
          // âœ… GCS ê²½ë¡œ ì •ë³´ ì €ì¥ (ì´ì „ 1789ë²ˆ ë¬¸ì œ í•´ê²°)
          gsPath: gcsResult.gsPath,
          gsThumbnailPath: gcsResult.gsThumbnailPath,
          fileName: gcsResult.fileName,
          storageType: "gcs"
        }),
        style: style
      }).returning();

      console.log("âœ… [ê°€ì¡±ì‚¬ì§„ ì €ì¥] DB ì €ì¥ ì™„ë£Œ:", savedImage.id);

      return res.status(200).json({
        id: savedImage.id,
        transformedUrl: savedImage.transformedUrl,
        originalUrl: savedImage.originalUrl,
        style: savedImage.style,
        prompt: prompt,
        createdAt: savedImage.createdAt,
        categoryId: savedImage.categoryId
      });

    } catch (error) {
      console.error("âŒ [ê°€ì¡±ì‚¬ì§„ ìƒì„±] ì „ì²´ ì—ëŸ¬:", error);
      return res.status(500).json({
        error: "ê°€ì¡±ì‚¬ì§„ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // ğŸ­ ìŠ¤í‹°ì»¤ ì´ë¯¸ì§€ ìƒì„± API - image.tsë¡œ ì´ë™ë¨
    console.log("ğŸš€ [ìŠ¤í‹°ì»¤ ìƒì„±] API í˜¸ì¶œ ì‹œì‘");

    try {
      // ğŸ†” JWTì—ì„œ ì‚¬ìš©ì ID ì¶”ì¶œ (ì¤‘ìš”!)
      const userIdRaw = req.user!.userId || req.user!.id || req.user!.sub;
      const userId = Number(userIdRaw);
      
      if (!userId) {
        console.log("âŒ [ìŠ¤í‹°ì»¤ ìƒì„±] ì‚¬ìš©ì ID ëˆ„ë½");
        return res.status(400).json({ error: "ì‚¬ìš©ì ì¸ì¦ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤" });
      }

      console.log(`ğŸ‘¤ [ìŠ¤í‹°ì»¤ ìƒì„±] ì‚¬ìš©ì ID: ${userId}`);

      // ğŸ” ìš”ì²­ íŒŒë¼ë¯¸í„° ê²€ì¦
      const requestBodySchema = z.object({
        style: z.string().min(1, "ìŠ¤íƒ€ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”"),
        variables: z.union([z.string(), z.object({}).passthrough()]).optional(),
        model: z.string().optional()
      });

      let parsedBody;
      try {
        parsedBody = requestBodySchema.parse(req.body);
      } catch (validationError) {
        if (validationError instanceof z.ZodError) {
          console.log("âŒ [ìŠ¤í‹°ì»¤ ìƒì„±] íŒŒë¼ë¯¸í„° ê²€ì¦ ì‹¤íŒ¨:", validationError.errors);
          return res.status(400).json({
            error: "ìš”ì²­ íŒŒë¼ë¯¸í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤",
            details: validationError.errors
          });
        }
        throw validationError;
      }

      const { style, variables, model } = parsedBody;

      // ğŸ¨ ì»¨ì…‰ ì •ë³´ ë¨¼ì € ì¡°íšŒ (generationType í™•ì¸ì„ ìœ„í•´)
      console.log(`ğŸ” [ì»¨ì…‰ ì¡°íšŒ] ${style} ì»¨ì…‰ ê²€ìƒ‰ ì¤‘...`);

      const concept = await db.query.concepts.findFirst({
        where: eq(concepts.conceptId, style)
      });

      if (!concept) {
        console.log("âŒ [ìŠ¤í‹°ì»¤ ìƒì„±] ì»¨ì…‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ");
        return res.status(400).json({ error: "ì„ íƒí•œ ìŠ¤íƒ€ì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      // generationType í™•ì¸ í›„ ì¡°ê±´ë¶€ íŒŒì¼ ê²€ì¦
      const generationType = concept.generationType || "image_upload";
      const requiresImageUpload = generationType === "image_upload";

      console.log(`ğŸ“‹ [ì»¨ì…‰ ë°œê²¬] ${style} ì»¨ì…‰ ì •ë³´:`, {
        title: concept.title,
        generationType: generationType,
        requiresImageUpload: requiresImageUpload,
        availableModels: concept.availableModels
      });

      // ğŸ”’ ìš”ì²­ëœ ëª¨ë¸ ê²€ì¦ (ì˜ëª»ëœ ëª¨ë¸ ìš”ì²­ ì‹œ 400 ì—ëŸ¬ ë°˜í™˜)
      const modelValidation = await validateRequestedModel(model, concept.availableModels as string[] | null | undefined);
      if (!modelValidation.isValid && modelValidation.error) {
        console.log(`âŒ [ëª¨ë¸ ê²€ì¦ ì‹¤íŒ¨] ${modelValidation.error.requestedModel}ëŠ” ì§€ì›ë˜ì§€ ì•ŠëŠ” ëª¨ë¸ì…ë‹ˆë‹¤`);
        return res.status(400).json({
          error: modelValidation.error.message,
          requestedModel: modelValidation.error.requestedModel,
          allowedModels: modelValidation.error.allowedModels
        });
      }

      // ğŸ”’ AI ëª¨ë¸ ê²°ì • (ìš”ì²­ ëª¨ë¸ â†’ ì»¨ì…‰ ì œí•œ â†’ ì‹œìŠ¤í…œ ê¸°ë³¸ê°’)
      const finalModel = await resolveAiModel(model, concept.availableModels as string[] | null | undefined);
      console.log(`âœ… [AI ëª¨ë¸ ê²°ì •] ìµœì¢… ì„ íƒëœ ëª¨ë¸: ${finalModel} (ìš”ì²­: ${model || 'none'})`);

      // íŒŒì¼ì´ í•„ìš”í•œ ê²½ìš°ì—ë§Œ íŒŒì¼ ê²€ì¦
      if (requiresImageUpload && !req.file) {
        console.log("âŒ [ìŠ¤í‹°ì»¤ ìƒì„±] ì´ë¯¸ì§€ ì—…ë¡œë“œê°€ í•„ìš”í•œ ì»¨ì…‰ì¸ë° íŒŒì¼ì´ ì—…ë¡œë“œë˜ì§€ ì•ŠìŒ");
        return res.status(400).json({ error: "ì´ë¯¸ì§€ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”" });
      }

      console.log("ğŸ“ [ìŠ¤í‹°ì»¤ ìƒì„±] ìš”ì²­ ì •ë³´:");
      console.log("- íŒŒì¼:", req.file?.filename || "ì—†ìŒ (í…ìŠ¤íŠ¸ ì „ìš©)");
      console.log("- ìŠ¤íƒ€ì¼:", style);
      console.log("- ë³€ìˆ˜:", variables);
      console.log("- ìƒì„± ë°©ì‹:", generationType);

      // í•„ìš”í•œ ëª¨ë“ˆë“¤ì„ ë¨¼ì € import
      const pathModule = await import('path');
      const fsModule = await import('fs');
      const fetch = (await import('node-fetch')).default;
      const sharp = (await import('sharp')).default;
      const { v4: uuidv4 } = await import('uuid');

      // ë³€ìˆ˜ íŒŒì‹±
      let parsedVariables = {};
      if (variables) {
        try {
          parsedVariables = typeof variables === 'string' ? JSON.parse(variables) : variables;
          console.log("âœ… [ìŠ¤í‹°ì»¤ ìƒì„±] ë³€ìˆ˜ íŒŒì‹± ì„±ê³µ:", parsedVariables);
        } catch (e) {
          console.log("âš ï¸ [ìŠ¤í‹°ì»¤ ìƒì„±] ë³€ìˆ˜ íŒŒì‹± ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©");
        }
      }

      // ğŸ¨ ì»¨ì…‰ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±
      let prompt = "A beautiful sticker-style character with clean lines and vibrant colors";
      let systemPrompt: string | null = null;

      // ì´ë¯¸ ìœ„ì—ì„œ ì¡°íšŒí•œ concept ì‚¬ìš© (conceptëŠ” í•­ìƒ ì¡´ì¬í•¨ - ìœ„ì—ì„œ ê²€ì¦í•¨)
      console.log(`ğŸ“‹ [ì»¨ì…‰ ë°œê²¬] ${style} ì»¨ì…‰ ì •ë³´:`, {
        title: concept.title,
        hasSystemPrompt: !!(concept.systemPrompt && concept.systemPrompt.trim()),
        hasPromptTemplate: !!(concept.promptTemplate && concept.promptTemplate.trim())
      });

      // ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
      if (concept.systemPrompt && concept.systemPrompt.trim() !== '') {
        console.log(`ğŸ¯ [ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸] ì ìš©:`, concept.systemPrompt.substring(0, 100) + "...");
        systemPrompt = concept.systemPrompt;

        // ê³µí†µ ë³€ìˆ˜ ì¹˜í™˜ í•¨ìˆ˜ ì‚¬ìš© (ê¸°ì¡´ {var}ì™€ ìƒˆë¡œìš´ {{var}} í˜•ì‹ ëª¨ë‘ ì§€ì›)
        if (parsedVariables && Object.keys(parsedVariables).length > 0) {
          console.log(`ğŸ”„ [ë³€ìˆ˜ ì¹˜í™˜] ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ë³€ìˆ˜ ì ìš© ì¤‘...`);
          systemPrompt = applyTemplateVariables(systemPrompt, parsedVariables);
        }
      }

      // ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì ìš©
      if (concept.promptTemplate && concept.promptTemplate.trim() !== '') {
        console.log(`ğŸ¯ [í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿] ì ìš©:`, concept.promptTemplate.substring(0, 100) + "...");
        prompt = concept.promptTemplate;

        // ê³µí†µ ë³€ìˆ˜ ì¹˜í™˜ í•¨ìˆ˜ ì‚¬ìš© (ê¸°ì¡´ {var}ì™€ ìƒˆë¡œìš´ {{var}} í˜•ì‹ ëª¨ë‘ ì§€ì›)
        if (parsedVariables && Object.keys(parsedVariables).length > 0) {
          console.log(`ğŸ”„ [ë³€ìˆ˜ ì¹˜í™˜] í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ì— ë³€ìˆ˜ ì ìš© ì¤‘...`);
          prompt = applyTemplateVariables(prompt, parsedVariables);
        }
      }

      console.log("ğŸ¨ [ìŠ¤í‹°ì»¤ ìƒì„±] ìµœì¢… í”„ë¡¬í”„íŠ¸:", prompt);
      if (systemPrompt) {
        console.log("ğŸ”§ [ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸] ì „ë‹¬ë¨:", systemPrompt.substring(0, 100) + "...");
      }

      // íŒŒì¼ ë²„í¼ ì²˜ë¦¬ - íŒŒì¼ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ
      let imageBuffer: Buffer | null = null;

      if (req.file) {
        if (req.file.buffer && req.file.buffer.length > 0) {
          // ë©”ëª¨ë¦¬ ì €ì¥ ë°©ì‹
          imageBuffer = req.file.buffer;
          console.log("ğŸ“ ìŠ¤í‹°ì»¤ ìƒì„± - ë©”ëª¨ë¦¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');
        } else if (req.file.path) {
          // ë””ìŠ¤í¬ ì €ì¥ ë°©ì‹ - íŒŒì¼ ê²½ë¡œì—ì„œ ì½ê¸°
          imageBuffer = fs.readFileSync(req.file.path);
          console.log("ğŸ“ ìŠ¤í‹°ì»¤ ìƒì„± - ë””ìŠ¤í¬ ê¸°ë°˜ íŒŒì¼ ì²˜ë¦¬:", imageBuffer.length, 'bytes');

          // ì„ì‹œ íŒŒì¼ ì‚­ì œ
          fs.unlinkSync(req.file.path);
        } else {
          console.error("âŒ ìŠ¤í‹°ì»¤ ìƒì„± - íŒŒì¼ ë²„í¼ì™€ ê²½ë¡œ ëª¨ë‘ ì—†ìŒ");
          return res.status(500).json({
            success: false,
            message: "ì—…ë¡œë“œëœ íŒŒì¼ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
          });
        }
      }

      // ğŸ”¥ ëª¨ë¸ì— ë”°ë¥¸ ì´ë¯¸ì§€ ë³€í™˜ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
      let transformedImageUrl: string;

      if (finalModel === "gemini") {
        // Gemini í…ìŠ¤íŠ¸â†’ì´ë¯¸ì§€ ìƒì„± (ìŠ¤í‹°ì»¤ ìƒì„±ì€ ê¸°ì¡´ ì´ë¯¸ì§€ê°€ í•„ìš”í•˜ì§€ ì•ŠìŒ)
        console.log("ğŸš€ [ìŠ¤í‹°ì»¤ ìƒì„±] Gemini í…ìŠ¤íŠ¸â†’ì´ë¯¸ì§€ ìƒì„± ì‹œì‘");
        const geminiService = await import('./services/gemini');
        
        // ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì™€ í”„ë¡¬í”„íŠ¸ë¥¼ ê²°í•©
        const finalPrompt = systemPrompt 
          ? `${systemPrompt}\n\n${prompt}`
          : prompt;
        
        transformedImageUrl = await geminiService.generateImageWithGemini25(finalPrompt);
        console.log("âœ… [ìŠ¤í‹°ì»¤ ìƒì„±] Gemini ì´ë¯¸ì§€ ìƒì„± ê²°ê³¼:", transformedImageUrl);
      } else {
        // OpenAI í…ìŠ¤íŠ¸â†’ì´ë¯¸ì§€ ìƒì„± (ìŠ¤í‹°ì»¤ ìƒì„±ì€ ê¸°ì¡´ ì´ë¯¸ì§€ê°€ í•„ìš”í•˜ì§€ ì•ŠìŒ)
        console.log("ğŸ”¥ [ìŠ¤í‹°ì»¤ ìƒì„±] OpenAI í…ìŠ¤íŠ¸â†’ì´ë¯¸ì§€ ìƒì„± ì‹œì‘");
        const openaiService = await import('./services/openai');
        
        // ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì™€ í”„ë¡¬í”„íŠ¸ë¥¼ ê²°í•©
        const finalPrompt = systemPrompt 
          ? `${systemPrompt}\n\n${prompt}`
          : prompt;
        
        transformedImageUrl = await openaiService.generateImageWithDALLE(finalPrompt);
        console.log("âœ… [ìŠ¤í‹°ì»¤ ìƒì„±] OpenAI ì´ë¯¸ì§€ ìƒì„± ê²°ê³¼:", transformedImageUrl);
      }

      if (!transformedImageUrl || transformedImageUrl.includes('placehold.co')) {
        console.error("ğŸš¨ ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨");
        return res.status(500).json({
          success: false,
          message: "ì´ë¯¸ì§€ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
        });
      }

      // ğŸ”½ ì´ë¯¸ì§€ë¥¼ GCSì— ì§ì ‘ ì €ì¥ (ì¸ë„¤ì¼ ìë™ ìƒì„±)
      console.log("ğŸ“¤ [ìŠ¤í‹°ì»¤ ì €ì¥] GCS ì €ì¥ ì‹œì‘...");

      // ì‚¬ìš©ì ID ì˜¬ë°”ë¥¸ ê²€ì¦
      const uid3 = validateUserId(req, res);
      if (!uid3) return;
      const stickerUserId = String(uid3);

      let imageResult;

      if (finalModel?.toLowerCase() === "gemini" && transformedImageUrl.startsWith('/uploads/')) {
        // GeminiëŠ” ì´ë¯¸ ë¡œì»¬ì— ì €ì¥ë˜ì–´ ìˆìŒ
        console.log("âœ… [Gemini] ë¡œì»¬ íŒŒì¼ì—ì„œ GCS ì—…ë¡œë“œ:", transformedImageUrl);

        // ì˜¬ë°”ë¥¸ ë¡œì»¬ íŒŒì¼ ê²½ë¡œ ì²˜ë¦¬ (ê°€ì¡±ì‚¬ì§„ê³¼ ë™ì¼í•œ ë°©ì‹)
        const normalizedPath = transformedImageUrl.startsWith('/')
          ? transformedImageUrl.substring(1)
          : transformedImageUrl;
        const localFilePath = path.join(process.cwd(), normalizedPath);

        try {
          // ë¹„ë™ê¸° íŒŒì¼ ì½ê¸° (ì´ë²¤íŠ¸ ë£¨í”„ ì°¨ë‹¨ ë°©ì§€)
          const imageBuffer = await fs.promises.readFile(localFilePath);

          imageResult = await saveImageToGCS(
            imageBuffer,
            stickerUserId,
            'sticker_img',
            `sticker_${style}_generated`
          );
        } catch (fileError) {
          console.error("âŒ [Gemini] ë¡œì»¬ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨:", fileError);
          return res.status(500).json({
            error: "ìƒì„±ëœ ì´ë¯¸ì§€ íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
          });
        }
      } else {
        // OpenAI: URLì—ì„œ ë‹¤ìš´ë¡œë“œ í›„ GCS ì—…ë¡œë“œ
        console.log("ğŸŒ [OpenAI] URLì—ì„œ GCS ì—…ë¡œë“œ:", transformedImageUrl);
        const { saveImageFromUrlToGCS } = await import('./utils/gcs-image-storage');
        imageResult = await saveImageFromUrlToGCS(
          transformedImageUrl,
          String(userId),  // ğŸ‘ˆ ì•ˆì „í•˜ê²Œ ë¬¸ìì—´ë¡œ ë³€í™˜
          'sticker_img',
          `sticker_${style}_generated`
        );
      }

      console.log("âœ… [ìŠ¤í‹°ì»¤ ì €ì¥] GCS ì €ì¥ ì™„ë£Œ:", imageResult.originalUrl);

      // ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ì— ì´ë¯¸ì§€ ì €ì¥
      // ì‚¬ìš©ì IDëŠ” ì´ë¯¸ ìœ„ì—ì„œ ê²€ì¦ë¨ (ì¤‘ë³µ ì œê±°)

      const [savedImage] = await db.insert(images).values({
        title: `sticker_${style}_generated`,
        transformedUrl: imageResult.originalUrl,
        originalUrl: imageResult.originalUrl,
        thumbnailUrl: imageResult.thumbnailUrl,
        userId: String(userId),
        categoryId: "sticker_img",
        conceptId: style,
        metadata: JSON.stringify({
          prompt,
          variables: parsedVariables,
          categoryId: "sticker_img",
          conceptId: style,
          gsPath: imageResult.gsPath,
          gsThumbnailPath: imageResult.gsThumbnailPath,
          fileName: imageResult.fileName,
          storageType: 'gcs'
        }),
        style: style
      }).returning();

      console.log("âœ… [ìŠ¤í‹°ì»¤ ì €ì¥] DB ì €ì¥ ì™„ë£Œ:", savedImage.id);

      return res.status(200).json({
        id: savedImage.id,
        transformedUrl: imageResult.originalUrl,
        originalUrl: imageResult.originalUrl,
        thumbnailUrl: imageResult.thumbnailUrl,
        style: savedImage.style,
        prompt: prompt,
        createdAt: savedImage.createdAt,
        categoryId: savedImage.categoryId
      });

    } catch (error) {
      console.error("âŒ [ìŠ¤í‹°ì»¤ ìƒì„±] ì „ì²´ ì—ëŸ¬:", error);
      return res.status(500).json({
        error: "ìŠ¤í‹°ì»¤ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // SignedURLì„ ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜í•˜ëŠ” ì¤‘ì•™ ì§‘ì¤‘ì‹ í•¨ìˆ˜
  const convertSignedUrlToDirectUrl = (url: string): string => {
    if (!url) return url;

    // SignedURL ê°ì§€ ë° ë³€í™˜
    if (url.includes('GoogleAccessId=') || url.includes('Signature=')) {
      try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        if (pathname.includes('/createtree-upload/')) {
          const filePath = pathname.substring(pathname.indexOf('/createtree-upload/') + '/createtree-upload/'.length);
          const directUrl = `https://storage.googleapis.com/createtree-upload/${filePath}`;
          console.log(`[URL ë³€í™˜] SignedURL â†’ ì§ì ‘ URL: ${directUrl}`);
          return directUrl;
        }
      } catch (error) {
        console.log(`[URL ë³€í™˜] íŒŒì‹± ì˜¤ë¥˜, ì›ë³¸ ìœ ì§€: ${url}`);
      }
    }

    return url;
  };

  // GCS ê³µê°œ URL ìƒì„± ê³µí†µ í•¨ìˆ˜
  const generatePublicUrl = (imagePath: string): string | null => {
    try {
      if (!imagePath) return null;

      // ì´ë¯¸ ì™„ì „í•œ HTTP URLì¸ ê²½ìš° SignedURL ë³€í™˜ ì ìš©
      if (imagePath.startsWith('http')) {
        return convertSignedUrlToDirectUrl(imagePath);
      }

      // gs:// í˜•ì‹ì¸ ê²½ìš° ê³µê°œ URLë¡œ ë³€í™˜
      if (imagePath.startsWith('gs://')) {
        const bucketName = imagePath.split('/')[2];
        const filePath = imagePath.split('/').slice(3).join('/');
        const publicUrl = `https://storage.googleapis.com/${bucketName}/${filePath}`;
        return publicUrl;
      }

      // ìƒëŒ€ ê²½ë¡œì¸ ê²½ìš° createtree-upload ë²„í‚· ì‚¬ìš©
      if (imagePath.startsWith('images/') || imagePath.includes('.webp')) {
        const cleanPath = imagePath.startsWith('/') ? imagePath.substring(1) : imagePath;
        const publicUrl = `https://storage.googleapis.com/createtree-upload/${cleanPath}`;
        return publicUrl;
      }

      // static ê²½ë¡œëŠ” ë¡œì»¬ ì„œë¹™ ìœ ì§€
      if (imagePath.startsWith('/static/')) {
        return imagePath;
      }

      // ë¡œì»¬ ì½œë¼ì£¼ ê²½ë¡œëŠ” ë¡œì»¬ ì„œë¹™ ìœ ì§€ (/uploads/collages/)
      if (imagePath.startsWith('/uploads/collages/')) {
        return imagePath;
      }

      // GCS ì½œë¼ì£¼ ê²½ë¡œ ì²˜ë¦¬ (collages/)
      if (imagePath.startsWith('collages/')) {
        return `https://storage.googleapis.com/createtree-upload/${imagePath}`;
      }

      // ê¸°íƒ€ ê²½ìš° createtree-upload ë²„í‚· ê¸°ë³¸ ê²½ë¡œ ì‚¬ìš©
      const publicUrl = `https://storage.googleapis.com/createtree-upload/${imagePath}`;
      return publicUrl;
    } catch (error) {
      console.error('GCS ê³µê°œ URL ìƒì„± ì‹¤íŒ¨:', error);
      return null;
    }
  };

  // Gallery endpoints - ê°„ì†Œí™”ëœ ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬
  app.get("/api/gallery", requireAuth, async (req, res) => {
    try {
      const filter = req.query.filter as string;
      const userId = req.user!.id;
      console.log(`[ê°¤ëŸ¬ë¦¬ API] ì‚¬ìš©ì ${userId} ê°œì¸ ê°¤ëŸ¬ë¦¬ ìš”ì²­ - í•„í„°: ${filter || 'all'}`);

      // ëª¨ë“  ì‚¬ìš©ìëŠ” ë³¸ì¸ì´ ìƒì„±í•œ ì´ë¯¸ì§€ë§Œ ì¡°íšŒ ê°€ëŠ¥
      let whereCondition;
      if (filter && filter !== 'all') {
        // collageëŠ” style í•„í„°, ë‚˜ë¨¸ì§€ëŠ” categoryId í•„í„°
        if (filter === 'collage') {
          whereCondition = and(
            eq(images.userId, userId.toString()),
            eq(images.style, 'collage')
          );
        } else {
          whereCondition = and(
            eq(images.userId, userId.toString()),
            eq(images.categoryId, filter)
          );
        }
      } else {
        whereCondition = eq(images.userId, userId.toString());
      }

      // ê°œì¸ ì´ë¯¸ì§€ë§Œ ì¡°íšŒ (ëª¨ë“  ì´ë¯¸ì§€ í‘œì‹œ)
      const imageItems = await db.query.images.findMany({
        where: whereCondition,
        orderBy: desc(images.createdAt)
      });

      const galleryItems = imageItems.map(image => {
        // SignedURLì„ ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜í•˜ëŠ” ê°„ë‹¨í•œ í•¨ìˆ˜
        const convertToDirectUrl = (url: string): string => {
          try {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            if (pathname.includes('/createtree-upload/')) {
              const filePath = pathname.substring(pathname.indexOf('/createtree-upload/') + '/createtree-upload/'.length);
              return `https://storage.googleapis.com/createtree-upload/${filePath}`;
            }
            return url;
          } catch (error) {
            return url;
          }
        };

        const baseUrl = generatePublicUrl(image.transformedUrl || image.originalUrl);
        const transformedUrl = baseUrl ? convertToDirectUrl(baseUrl) : '';

        const origUrl = generatePublicUrl(image.originalUrl);
        const originalUrl = origUrl ? convertToDirectUrl(origUrl) : '';

        // ì¸ë„¤ì¼ì´ ì—†ê±°ë‚˜ ì ‘ê·¼ ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©
        let thumbnailUrl = transformedUrl;
        if (image.thumbnailUrl) {
          const thumbUrl = generatePublicUrl(image.thumbnailUrl);
          thumbnailUrl = thumbUrl ? convertToDirectUrl(thumbUrl) : transformedUrl;
        }

        return {
          id: image.id,
          title: image.title || `ìƒì„±ëœ ì´ë¯¸ì§€ - ${image.style || 'ìŠ¤íƒ€ì¼'}`,
          type: image.style === 'collage' ? 'collage' as const : image.categoryId || 'image' as const,
          url: thumbnailUrl, // ê°¤ëŸ¬ë¦¬ì—ì„œëŠ” ì¸ë„¤ì¼ ìš°ì„ , ì—†ìœ¼ë©´ ì›ë³¸
          transformedUrl: transformedUrl,
          thumbnailUrl: thumbnailUrl,
          originalUrl: originalUrl,
          style: image.style || '',
          userId: image.userId,
          createdAt: image.createdAt.toISOString(),
          isFavorite: false
        };
      });

      console.log(`[ê°¤ëŸ¬ë¦¬ API] ì „ì²´ ${galleryItems.length}ê°œ ì´ë¯¸ì§€ ë°˜í™˜`);
      res.json(galleryItems);
    } catch (error) {
      console.error('[ê°¤ëŸ¬ë¦¬ API] ì˜¤ë¥˜:', error);
      res.status(500).json({ error: 'ê°¤ëŸ¬ë¦¬ ë¡œë”© ì‹¤íŒ¨' });
    }
  });

  app.post("/api/gallery/favorite", async (req, res) => {
    try {
      res.json({ success: true, message: "ì¦ê²¨ì°¾ê¸° ê¸°ëŠ¥ì€ í˜„ì¬ ë¹„í™œì„±í™”ë¨" });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ errors: error.errors });
      }
      console.error("Error toggling favorite:", error);
      return res.status(500).json({ error: "Failed to toggle favorite" });
    }
  });

  // ê°¤ëŸ¬ë¦¬ ì´ë¯¸ì§€ ì‚­ì œ API
  app.delete("/api/gallery/:id", requireAuth, async (req, res) => {
    try {
      const imageId = parseInt(req.params.id);
      const userId = req.user!.id;

      if (isNaN(imageId)) {
        return res.status(400).json({ error: "ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë¯¸ì§€ IDì…ë‹ˆë‹¤." });
      }

      // ì´ë¯¸ì§€ ì¡´ì¬ ì—¬ë¶€ ë° ì†Œìœ ê¶Œ í™•ì¸
      const existingImage = await db.query.images.findFirst({
        where: and(
          eq(images.id, imageId),
          eq(images.userId, userId.toString())
        )
      });

      if (!existingImage) {
        return res.status(404).json({ error: "ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ ì‚­ì œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤." });
      }

      // ì´ë¯¸ì§€ ì‚­ì œ
      await db.delete(images).where(
        and(
          eq(images.id, imageId),
          eq(images.userId, userId.toString())
        )
      );

      console.log(`[ê°¤ëŸ¬ë¦¬ ì‚­ì œ] ì´ë¯¸ì§€ ID ${imageId} ì‚­ì œ ì™„ë£Œ`);

      res.json({
        success: true,
        message: "ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.",
        deletedId: imageId
      });
    } catch (error) {
      console.error("[ê°¤ëŸ¬ë¦¬ ì‚­ì œ] ì˜¤ë¥˜:", error);
      res.status(500).json({ error: "ì´ë¯¸ì§€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // Media management endpoints
  // OPTIONS ìš”ì²­ì„ ìœ„í•œ í—¤ë” ì¶”ê°€
  app.options("/api/media/download/:type/:id", (req, res) => {
    res.header('Allow', 'GET, HEAD, OPTIONS');
    res.status(200).end();
  });

  // HEAD ìš”ì²­ ì²˜ë¦¬ ì¶”ê°€ (ë‹¤ìš´ë¡œë“œ ê²€ì¦ìš©)
  app.head("/api/media/download/:type/:id", async (req, res) => {
    try {
      const { type, id } = req.params;
      const parsedId = parseInt(id);

      if (type !== "music" && type !== "image") {
        return res.status(400).end();
      }

      // ì„¸ì…˜ ì´ë¯¸ì§€ í™•ì¸ ë˜ëŠ” DB ì¡°íšŒ
      let url = '';
      let contentType = '';

      if (type === "image" && parsedId === -1 && req.session && req.session.tempImage) {
        url = req.session.tempImage.transformedUrl;
        contentType = 'image/jpeg';

        // ë¡œì»¬ íŒŒì¼ì´ ìˆìœ¼ë©´ ì„±ê³µ ì‘ë‹µ
        if (req.session.tempImage.localFilePath && fs.existsSync(req.session.tempImage.localFilePath)) {
          res.setHeader('Content-Type', contentType);
          return res.status(200).end();
        }
      } else {
        // DB ì¡°íšŒ
        const mediaItem = await storage.getMediaItem(parsedId, type);
        if (!mediaItem) {
          return res.status(404).end();
        }

        if (type === "music") {
          url = (mediaItem as typeof music.$inferSelect).url || '';
          contentType = 'audio/mpeg';
        } else {
          url = (mediaItem as typeof images.$inferSelect).transformedUrl;
          contentType = 'image/jpeg';

          // ë¡œì»¬ íŒŒì¼ í™•ì¸
          const urlBasename = path.basename(url);
          const possibleLocalPaths = [
            path.join(process.cwd(), 'uploads', urlBasename),
            path.join(process.cwd(), 'uploads', 'temp', urlBasename)
          ];

          for (const localPath of possibleLocalPaths) {
            if (fs.existsSync(localPath)) {
              res.setHeader('Content-Type', contentType);
              return res.status(200).end();
            }
          }
        }
      }

      // ë¡œì»¬ íŒŒì¼ì´ ì—†ëŠ” ê²½ìš° ì›ê²© URL í™•ì¸
      if (!url.startsWith('http')) {
        url = `https://${url}`;
      }

      try {
        const response = await fetch(url, {
          method: 'HEAD',
          headers: {
            'Accept': 'image/*,audio/*,*/*',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
          }
        });

        if (!response.ok) {
          return res.status(502).json({
            error: "ì›ê²© ì„œë²„ì—ì„œ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
            url: url
          });
        }

        // ì„±ê³µ ì‹œ ì»¨í…ì¸  íƒ€ì… ì„¤ì •
        res.setHeader('Content-Type', response.headers.get('content-type') || contentType);
        return res.status(200).end();
      } catch (error) {
        return res.status(502).json({
          error: "ì›ê²© URLì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
          url: url,
          message: error instanceof Error ? error.message : String(error)
        });
      }
    } catch (error) {
      console.error("Error in HEAD request:", error);
      return res.status(500).end();
    }
  });

  // GET ìš”ì²­ ì²˜ë¦¬ (ì‹¤ì œ ë‹¤ìš´ë¡œë“œ)
  app.get("/api/media/download/:type/:id", async (req, res) => {
    try {
      const { type, id } = req.params;
      const parsedId = parseInt(id);

      // CORS í—¤ë”ëŠ” ì¤‘ì•™ ë¯¸ë“¤ì›¨ì–´ì—ì„œ ì²˜ë¦¬
      res.header('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type, Accept, Origin, X-Requested-With');

      if (type !== "music" && type !== "image") {
        return res.status(400).json({ error: "Invalid media type" });
      }

      // ì„ì‹œ ì´ë¯¸ì§€ ì²˜ë¦¬ (-1 IDì¸ ê²½ìš° ì„ì‹œ ìºì‹œì—ì„œ ì°¾ê¸°)
      let url = '';
      let filename = '';
      let mediaItem;

      // ì„¸ì…˜ì—ì„œ ì„ì‹œ ì´ë¯¸ì§€ í™•ì¸ (IDê°€ -1ì¸ ê²½ìš°)
      if (type === "image" && parsedId === -1 && req.session && req.session.tempImage) {
        console.log("ì„ì‹œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ìš”ì²­ ì²˜ë¦¬ ì¤‘:", req.session.tempImage.title);

        // ë¡œì»¬ íŒŒì¼ ê²½ë¡œê°€ ìˆìœ¼ë©´ ì§ì ‘ íŒŒì¼ì„ ì½ì–´ì„œ ë°˜í™˜
        if (req.session.tempImage.localFilePath) {
          try {
            console.log(`ë¡œì»¬ íŒŒì¼ì—ì„œ ì½ê¸°: ${req.session.tempImage.localFilePath}`);
            const imageBuffer = fs.readFileSync(req.session.tempImage.localFilePath);
            filename = `${req.session.tempImage.title || 'transformed_image'}.jpg`;

            // ì‘ë‹µ í—¤ë” ì„¤ì •
            res.setHeader('Content-Type', 'image/jpeg');
            res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);

            // íŒŒì¼ ë°ì´í„° ì „ì†¡
            return res.send(imageBuffer);
          } catch (fileError) {
            console.error('ë¡œì»¬ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨:', fileError);
            // íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ ì‹œ ì›ë˜ URL ì‚¬ìš©
            url = req.session.tempImage.transformedUrl;
            filename = `${req.session.tempImage.title || 'transformed_image'}.jpg`;
          }
        } else {
          // ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ URLì—ì„œ ì½ê¸°
          url = req.session.tempImage.transformedUrl;
          filename = `${req.session.tempImage.title || 'transformed_image'}.jpg`;
        }
      } else {
        // ì •ìƒì ì¸ ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ
        try {
          mediaItem = await storage.getMediaItem(parsedId, type);

          if (!mediaItem) {
            return res.status(404).json({ error: "Media not found" });
          }

          if (type === "music") {
            const musicItem = mediaItem as typeof music.$inferSelect;
            url = musicItem.url || '';
            filename = `${musicItem.title || 'music'}.mp3`;

            console.log(`[ìŒì•… ë‹¤ìš´ë¡œë“œ] ID: ${parsedId}, URL: ${url}, íŒŒì¼ëª…: ${filename}`);

            // GCS URLì¸ ê²½ìš° SignedURLë¡œ ë‹¤ìš´ë¡œë“œ
            if (url.includes('storage.googleapis.com')) {
              try {
                // GCS íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ (ê¸°ì¡´ ìŠ¤íŠ¸ë¦¬ë° APIì™€ ë™ì¼í•œ ë¡œì§)
                const urlParts = url.split('/');
                const fileName = urlParts[urlParts.length - 1];
                const filePath = `music/${fileName}`;

                // SignedURL ìƒì„± (ê¸°ì¡´ ìŠ¤íŠ¸ë¦¬ë° APIì™€ ë™ì¼í•œ ë¡œì§)
                const { Storage } = await import('@google-cloud/storage');
                const serviceAccountKey = {
                  type: "service_account",
                  project_id: "createtreeai",
                  private_key_id: "5ae3581cc6a4ccdc012c18c0775fdd51614eee24",
                  private_key: "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCevUl+Y5xGrsVR\nhWJvr8stawdae+MWgy85E/zHKqN660EOjqY643Y//gp07NIb0XuJWTMbJcZYNLxi\nTcczDyggqPYn2UQUbdKIpp0XbiYkD/GLo1Hqi3CVPsIRa1xRT70S5Yx9q9rkAbxB\n+eF8gdxXQ8y+eIIhJRauZTbK7g5+f9Df8TRyjfofI8WZRNPXsQhqfpwQbp8VJwL8\nDCp7cXI2vIrCq7SbxlD02vdsaSQ97DGVIBF7Nr6QE6otSBxl4fqHYjmx6RfCAynz\nHWH1nOuYxkYszhDjawsVEaXjuGCa6SAzKmgHWaoXAM6V692lm+VLx9/1EO9b+r2I\nzJj5ak2/AgMBAAECggEAAk+gAwGLpWWMdDuTIcBR9GldUJyAMdMz3lWODsJK4n6V9\nG7I2ZA5iYn1nGHE5SAegKkOxiWRsbJzAUxhy3WedkC7Ws5yvmEkHNDggq6uEqf+AO\nEWnMPV166FoMkULVn9MwNym+GbqCRMt6MSSaP4BTEOhyx/bUA8zJwk8TW5f5vsavtxB\n6nyuo+kBS6ow4JVxFgIAs9R1MsvCBpu+OAwnHO4rnQKBgQDKtjIJf19ZccoHTndV\nAsjagQp6hibvDGelVNxq7pQDnZj2z8NH/lEX5KbAyhSHWURi/FHgzmuCybFZqs8d\nsuQd+MJekwsOYs7IONq00Pi9QE1xLMt4DCLhPj29BVa3Rn88/RcQOkCgcITKGs7+\nopqEnJDVKutEXKlykAH3qR0dewKBgQDId+gAwGLpWWMdDuTIcBR9GldUJyAMdMz3\nlWODsJK4n6V9G7I2ZA5iYn1nGHE5SAegKkOxiWRsbJzAUxhy3WedkC7Ws5yvmEkH\nNDggq6uEqf+AOEWnMPV166FoMkULVn9MwNym+GbqCRMt6dL12Px0Q+bBz+qUp9IH\nUQq62KfjjQKBgEg6CLQXnSqqf5iA3cX9ewFXzxr+56pvGhLvnKXBIh3zrkfqmSLy\nu4Qu5Td2CUB8jwBR9P6LrgToxnczhB6J2fvP4bl+3QagMBtpHowklSwhWDaGBm1c\nraTh32+VEmO1C6r4ZppSlypTTQ0R5kUWPMYZXwWFCFTQS1PVec37hLM3AoGBALGM\nYVKpEfGSVZIa6s4LVlomxkmmDWB64j41dVnhPVF/M9bGfORnYcYJbP+uSjltbjOQ\nEPpg7uVA/FehzFIpyA5BRVNKjnzy1bXdNR+fW7LRAoGBAK9yAL+ER3fIIHAHrYkd\nwOo4Agd6gRfVPpR2VclOWgwfG6vCiIccx+j9n4G2muJd5L0ZLGqOQMfKy4WjHdBR\n/SHg1s7YhbtVtddwdluSobZ03q6hztqMkejOaemngTMSvGOk8jlyFfmrgU0OcClf\nnEoJ2Uh1U2PmPz9iZuyUI2GA\n-----END PRIVATE KEY-----\n",
                  client_email: "upload-server@createtree.iam.gserviceaccount.com",
                  client_id: "115537304083050477734",
                  auth_uri: "https://accounts.google.com/o/oauth2/auth",
                  token_uri: "https://oauth2.googleapis.com/token",
                  auth_provider_x509_cert_url: "https://www.googleapis.com/oauth2/v1/certs",
                  client_x509_cert_url: "https://www.googleapis.com/robot/v1/metadata/x509/upload-server%40createtree.iam.gserviceaccount.com"
                };

                const storage = new Storage({
                  projectId: 'createtreeai',
                  credentials: serviceAccountKey
                });

                const bucket = storage.bucket('createtree-upload');
                const file = bucket.file(filePath);

                // SignedURL ìƒì„± (24ì‹œê°„ ìœ íš¨)
                const [signedUrl] = await file.getSignedUrl({
                  version: 'v4',
                  action: 'read',
                  expires: Date.now() + 24 * 60 * 60 * 1000, // 24ì‹œê°„
                });

                console.log(`[ìŒì•… ë‹¤ìš´ë¡œë“œ] SignedURL ìƒì„±: ${signedUrl.substring(0, 100)}...`);

                // ì‹¤ì œ ìŒì•… íŒŒì¼ ë‹¤ìš´ë¡œë“œ
                const fetch = await import('node-fetch');
                const response = await fetch.default(signedUrl);

                if (!response.ok) {
                  throw new Error(`GCS íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${response.status} ${response.statusText}`);
                }

                const musicBuffer = Buffer.from(await response.arrayBuffer());
                console.log(`[ìŒì•… ë‹¤ìš´ë¡œë“œ] íŒŒì¼ í¬ê¸°: ${musicBuffer.length} bytes`);

                if (musicBuffer.length < 1000) {
                  throw new Error(`ë‹¤ìš´ë¡œë“œëœ íŒŒì¼ì´ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤: ${musicBuffer.length} bytes`);
                }

                res.setHeader('Content-Type', 'audio/mpeg');
                res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);
                res.setHeader('Content-Length', musicBuffer.length.toString());

                return res.send(musicBuffer);

              } catch (musicError) {
                console.error(`[ìŒì•… ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜] ID: ${parsedId}:`, musicError);
                return res.status(500).json({
                  error: "ìŒì•… íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨",
                  message: musicError instanceof Error ? musicError.message : String(musicError)
                });
              }
            } else if (url.includes('audiopipe.suno.ai')) {
              // Suno URLì¸ ê²½ìš° í”„ë¡ì‹œ ë‹¤ìš´ë¡œë“œë¡œ ì²˜ë¦¬
              console.log(`[ìŒì•… ë‹¤ìš´ë¡œë“œ] ${musicItem.title} - Suno URL í”„ë¡ì‹œ ë‹¤ìš´ë¡œë“œ`);

              try {
                const fetch = (await import('node-fetch')).default;

                // Suno URLì—ì„œ ì˜¤ë””ì˜¤ íŒŒì¼ ê°€ì ¸ì˜¤ê¸°
                const audioResponse = await fetch(url, {
                  redirect: 'follow',
                  headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                  }
                });

                if (!audioResponse.ok) {
                  console.error(`[ìŒì•… ë‹¤ìš´ë¡œë“œ] Suno ì‘ë‹µ ì‹¤íŒ¨: ${audioResponse.status}`);
                  return res.status(500).json({ error: "ìŒì•… íŒŒì¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
                }

                if (!audioResponse.body) {
                  return res.status(500).json({ error: "ìŒì•… ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤" });
                }

                // ë‹¤ìš´ë¡œë“œ í—¤ë” ì„¤ì •
                const filename = `${musicItem.title || 'music'}.mp3`;
                res.setHeader('Content-Type', 'audio/mpeg');
                res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
                res.setHeader('Cache-Control', 'public, max-age=31536000'); // ì¼ë°˜ ì˜¤ë””ì˜¤ ìºì‹œ ì •ì±…

                // ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì „ì†¡
                audioResponse.body.pipe(res);

              } catch (proxyError) {
                console.error(`[ìŒì•… ë‹¤ìš´ë¡œë“œ] í”„ë¡ì‹œ ì˜¤ë¥˜:`, proxyError);
                return res.status(500).json({ error: "ìŒì•… ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" });
              }
            } else {
              // ê¸°íƒ€ ì™¸ë¶€ URLì¸ ê²½ìš° ë¦¬ë‹¤ì´ë ‰íŠ¸
              console.log(`[ìŒì•… ë‹¤ìš´ë¡œë“œ] ${musicItem.title} - ì™¸ë¶€ URLë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸`);
              return res.redirect(302, url);
            }
          } else {
            const imageItem = mediaItem as typeof images.$inferSelect;
            url = imageItem.transformedUrl;
            filename = `${imageItem.title || 'transformed_image'}.jpg`;

            // uploads í´ë” ë‚´ì— ì´ë¯¸ì§€ íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
            const urlBasename = path.basename(imageItem.transformedUrl);
            const possibleLocalPaths = [
              path.join(process.cwd(), 'uploads', urlBasename),
              path.join(process.cwd(), 'uploads', 'temp', urlBasename)
            ];

            for (const localPath of possibleLocalPaths) {
              if (fs.existsSync(localPath)) {
                console.log(`ë¡œì»¬ì—ì„œ ì´ë¯¸ì§€ íŒŒì¼ ì°¾ìŒ: ${localPath}`);
                try {
                  const imageBuffer = fs.readFileSync(localPath);
                  // ì‘ë‹µ í—¤ë” ì„¤ì •
                  res.setHeader('Content-Type', 'image/jpeg');
                  res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);
                  // íŒŒì¼ ë°ì´í„° ì „ì†¡
                  return res.send(imageBuffer);
                } catch (fileError) {
                  console.error('ë¡œì»¬ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨:', fileError);
                  // íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ ì‹œ ê³„ì† ì§„í–‰ (ì›ê²© URL ì‹œë„)
                  break;
                }
              }
            }
          }
        } catch (dbError) {
          console.error("DBì—ì„œ ë¯¸ë””ì–´ ì¡°íšŒ ì‹¤íŒ¨:", dbError);
          return res.status(500).json({ error: "ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ ì‹¤íŒ¨", message: dbError instanceof Error ? dbError.message : String(dbError) });
        }
      }

      // ì´ë¯¸ì§€ ì—†ì´ ë°”ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ URL ë°˜í™˜í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½
      if (url) {
        console.log(`[ë¯¸ë””ì–´ ë‹¤ìš´ë¡œë“œ] ID: ${parsedId}, URL: ${url.substring(0, 50)}...`);

        // base64 ë°ì´í„°ì¸ì§€ í™•ì¸
        if (url.startsWith('data:')) {
          console.log('âœ… Base64 ë°ì´í„° ê°ì§€ë¨. ì²˜ë¦¬ ì¤‘...');
          try {
            // data:image/png;base64,... í˜•íƒœì—ì„œ ì‹¤ì œ base64 ë°ì´í„° ì¶”ì¶œ
            const base64Data = url.split(',')[1];
            if (!base64Data) {
              throw new Error('Base64 ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            }

            const buffer = Buffer.from(base64Data, 'base64');
            console.log('Base64 ë²„í¼ í¬ê¸°:', buffer.length, 'bytes');

            // MIME íƒ€ì… ì¶”ì¶œ
            const mimeMatch = url.match(/data:([^;]+)/);
            const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';
            console.log('MIME íƒ€ì…:', mimeType);

            res.setHeader('Content-Type', mimeType);
            res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);
            console.log('âœ… Base64 ì´ë¯¸ì§€ ì „ì†¡ ì™„ë£Œ');
            return res.send(buffer);
          } catch (base64Error) {
            console.error('âŒ Base64 ë°ì´í„° ì²˜ë¦¬ ì‹¤íŒ¨:', base64Error);
            return res.status(500).json({ error: "Base64 ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
          }
        }

        // ğŸ¯ ë¡œì»¬ íŒŒì¼ ì§ì ‘ ë‹¤ìš´ë¡œë“œ (ìƒˆë¡œìš´ íŒŒì¼ ì‹œìŠ¤í…œ)
        if (url.startsWith('/uploads/') || url.startsWith('/static/banner/')) {
          try {
            const fullPath = path.join(process.cwd(), url);
            console.log(`[ë¡œì»¬ ë‹¤ìš´ë¡œë“œ] íŒŒì¼ ê²½ë¡œ: ${fullPath}`);

            if (fs.existsSync(fullPath)) {
              // íŒŒì¼ í™•ì¥ìì— ë”°ë¥¸ MIME íƒ€ì… ì„¤ì •
              const ext = path.extname(fullPath).toLowerCase();
              let contentType = 'image/jpeg';
              let downloadExt = '.jpg';

              if (ext === '.webp') {
                contentType = 'image/webp';
                downloadExt = '.webp';
              } else if (ext === '.png') {
                contentType = 'image/png';
                downloadExt = '.png';
              }

              // ì˜¬ë°”ë¥¸ í™•ì¥ìë¡œ íŒŒì¼ëª… ì„¤ì •
              const titleWithoutExt = (filename.split('.')[0] || 'image');
              const correctFilename = `${titleWithoutExt}${downloadExt}`;

              console.log(`[ë‹¤ìš´ë¡œë“œ] íŒŒì¼íƒ€ì…: ${contentType}, íŒŒì¼ëª…: ${correctFilename}`);

              const fileBuffer = fs.readFileSync(fullPath);
              res.setHeader('Content-Type', contentType);
              res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(correctFilename)}"`);
              res.setHeader('Content-Length', fileBuffer.length.toString());

              return res.send(fileBuffer);
            } else {
              console.log(`[ì˜¤ë¥˜] íŒŒì¼ ì—†ìŒ: ${fullPath}`);
            }
          } catch (localFileError) {
            console.error("[ë¡œì»¬ íŒŒì¼ ì˜¤ë¥˜]:", localFileError);
          }
        }

        // ğŸš« êµ¬ë²„ì „ ì›ê²© ë‹¤ìš´ë¡œë“œ ë¡œì§ ì œê±°
        // ëª¨ë“  ì´ë¯¸ì§€ëŠ” ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œì— ì €ì¥ë˜ì–´ì•¼ í•¨
        console.log(`[ì˜¤ë¥˜] ë¡œì»¬ íŒŒì¼ì´ ì•„ë‹Œ URL: ${url}`);
        return res.status(404).json({
          error: "ë¡œì»¬ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
          message: "ëª¨ë“  ì´ë¯¸ì§€ëŠ” ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œì— ì €ì¥ë˜ì–´ì•¼ í•©ë‹ˆë‹¤"
        });
      } else {
        return res.status(404).json({ error: "ë‹¤ìš´ë¡œë“œí•  URLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." });
      }
    } catch (error) {
      console.error("Error downloading media:", error);
      return res.status(500).json({
        error: "Failed to download media",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  });

  app.post("/api/media/share", async (req, res) => {
    try {
      console.log("ë¯¸ë””ì–´ ê³µìœ  ìš”ì²­ ìˆ˜ì‹ :", req.body);
      const validatedData = mediaShareSchema.parse(req.body);

      // CORS í—¤ë”ëŠ” ì¤‘ì•™ ë¯¸ë“¤ì›¨ì–´ì—ì„œ ì²˜ë¦¬
      res.header('Access-Control-Allow-Methods', 'POST, OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type, Accept, Origin, X-Requested-With');

      try {
        // ì„ì‹œ ì´ë¯¸ì§€ ì²˜ë¦¬ (IDê°€ -1ì¸ ê²½ìš°)
        if (validatedData.type === 'image' && validatedData.id === -1 && req.session && req.session.tempImage) {
          console.log("ì„ì‹œ ì´ë¯¸ì§€ ê³µìœ  ì‹œë„:", req.session.tempImage.title);

          // ì„ì‹œ ì´ë¯¸ì§€ì˜ URL ìƒì„±
          let shareUrl = '';
          if (req.session.tempImage.localFilePath) {
            // í˜„ì¬ ë„ë©”ì¸ ê¸°ë°˜ìœ¼ë¡œ URL ìƒì„±
            const baseUrl = `${req.protocol}://${req.get('host')}`;
            const relativePath = req.session.tempImage.localFilePath.replace(process.cwd(), '');
            shareUrl = `${baseUrl}${relativePath.replace(/\\/g, '/').replace('/uploads', '/uploads')}`;
            console.log("ì„ì‹œ ì´ë¯¸ì§€ ê³µìœ  URL ìƒì„±:", shareUrl);

            // URLì´ ì˜¬ë°”ë¥¸ í˜•ì‹ì¸ì§€ í™•ì¸
            if (!shareUrl.includes('://')) {
              shareUrl = `${req.protocol}://${req.get('host')}${shareUrl.startsWith('/') ? '' : '/'}${shareUrl}`;
            }

            return res.json({
              shareUrl,
              message: "ì„ì‹œ ì´ë¯¸ì§€ URLì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ URLì„ í†µí•´ ë¯¸ë””ì–´ë¥¼ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
            });
          }
        }

        // ë¯¸ë””ì–´ ì•„ì´í…œ ì¡°íšŒ
        console.log(`ë¯¸ë””ì–´ ì¡°íšŒ ì‹œë„ - ID: ${validatedData.id}, íƒ€ì…: ${validatedData.type}`);
        const mediaItem = await storage.getMediaItem(
          validatedData.id,
          validatedData.type
        );

        if (!mediaItem) {
          console.error(`ë¯¸ë””ì–´ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ - ID: ${validatedData.id}, íƒ€ì…: ${validatedData.type}`);
          return res.status(404).json({
            error: "Media not found",
            message: "ê³µìœ í•  ë¯¸ë””ì–´ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
          });
        }

        console.log("ë¯¸ë””ì–´ í•­ëª© ì°¾ìŒ:", mediaItem);

        // ë¯¸ë””ì–´ íƒ€ì…ì— ë”°ë¼ URL ì§ì ‘ ë°˜í™˜
        let shareUrl = '';
        if (validatedData.type === 'image') {
          const imageItem = mediaItem as typeof images.$inferSelect;
          shareUrl = imageItem.transformedUrl;

          // URLì´ ë¡œì»¬ íŒŒì¼ ê²½ë¡œì¸ ê²½ìš° ì›¹ ì ‘ê·¼ ê°€ëŠ¥í•œ URLë¡œ ë³€í™˜
          if (!shareUrl.includes('://')) {
            const baseUrl = `${req.protocol}://${req.get('host')}`;
            shareUrl = `${baseUrl}${shareUrl.startsWith('/') ? '' : '/'}${shareUrl}`;
          }
        } else if (validatedData.type === 'music') {
          const musicItem = mediaItem as typeof music.$inferSelect;
          shareUrl = musicItem.url || '';

          // URLì´ ë¡œì»¬ íŒŒì¼ ê²½ë¡œì¸ ê²½ìš° ì›¹ ì ‘ê·¼ ê°€ëŠ¥í•œ URLë¡œ ë³€í™˜
          if (!shareUrl.includes('://')) {
            const baseUrl = `${req.protocol}://${req.get('host')}`;
            shareUrl = `${baseUrl}${shareUrl.startsWith('/') ? '' : '/'}${shareUrl}`;
          }
        }

        // URLì´ ìˆëŠ” ê²½ìš° ì§ì ‘ ë°˜í™˜
        if (shareUrl) {
          return res.json({
            shareUrl,
            message: "ë¯¸ë””ì–´ URLì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ URLì„ í†µí•´ ë¯¸ë””ì–´ë¥¼ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
          });
        }

        // ì—†ëŠ” ê²½ìš°ì—ëŠ” ê¸°ì¡´ ë¡œì§ ì§„í–‰
        const shareLink = await storage.createShareLink(
          validatedData.id,
          validatedData.type
        );

        return res.json({ shareUrl: shareLink });
      } catch (lookupError) {
        console.error("ë¯¸ë””ì–´ ì¡°íšŒ ì‹¤íŒ¨:", lookupError);
        return res.status(500).json({
          error: "Media lookup failed",
          message: "ë¯¸ë””ì–´ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        });
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ errors: error.errors });
      }
      console.error("Error sharing media:", error);
      return res.status(500).json({ error: "Failed to share media" });
    }
  });

  // Milestone and Pregnancy Profile endpoints

  // Get or update the pregnancy profile
  app.get("/api/pregnancy-profile", requireAuth, async (req, res) => {
    try {
      // JWTì—ì„œ userId ì¶”ì¶œí•˜ê³  ìˆ«ìë¡œ ë³€í™˜
      const userIdRaw = req.user!.userId || req.user!.id || req.user!.sub;
      const userId = Number(userIdRaw);

      console.log("[í”„ë¡œí•„ ì¡°íšŒ] ì‚¬ìš©ì ID:", userId, "íƒ€ì…:", typeof userId);

      const { getOrCreatePregnancyProfile } = await import("./services/milestones");
      const profile = await getOrCreatePregnancyProfile(userId);
      return res.json(profile || { error: "No profile found" });
    } catch (error) {
      console.error("Error fetching pregnancy profile:", error);
      return res.status(500).json({ error: "Failed to fetch pregnancy profile" });
    }
  });

  app.post("/api/pregnancy-profile", requireAuth, async (req, res) => {
    try {
      // JWTì—ì„œ userId ì¶”ì¶œí•˜ê³  ìˆ«ìë¡œ ë³€í™˜
      const userIdRaw = req.user!.userId || req.user!.id || req.user!.sub;
      const userId = Number(userIdRaw);

      console.log("[í”„ë¡œí•„ ì €ì¥] ì‚¬ìš©ì ID:", userId, "íƒ€ì…:", typeof userId);

      const { updatePregnancyProfile } = await import("./services/milestones");
      const profileData = req.body;

      // Ensure dueDate is a proper Date object if provided
      if (profileData.dueDate) {
        profileData.dueDate = new Date(profileData.dueDate);
      }

      const profile = await updatePregnancyProfile(userId, profileData);

      if (!profile) {
        return res.status(400).json({ error: "Failed to update profile - dueDate is required" });
      }

      return res.json(profile);
    } catch (error) {
      console.error("Error updating pregnancy profile:", error);
      return res.status(500).json({ error: "Failed to update pregnancy profile" });
    }
  });


  // ê¶Œí•œ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ì „ìš© API
  app.post("/api/test-permissions", requireAuth, requirePremiumAccess, requireActiveHospital(), (req, res) => {
    res.json({
      success: true,
      message: "ê¶Œí•œ í™•ì¸ ì™„ë£Œ - ëª¨ë“  ê¶Œí•œ ë¯¸ë“¤ì›¨ì–´ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤",
      userInfo: {
        id: req.user?.id,
        memberType: req.user?.memberType,
        hospitalId: req.user?.hospitalId,
        hasPermission: true
      },
      timestamp: new Date().toISOString()
    });
  });



  // API to increment usage count for a persona (for recommendation engine)
  app.post("/api/personas/:id/use", async (req, res) => {
    try {
      const personaId = req.params.id;

      // Check if persona exists
      const existingPersona = await db.query.personas.findFirst({
        where: eq(personas.personaId, personaId)
      });

      if (!existingPersona) {
        return res.status(404).json({ error: "Persona not found" });
      }

      // Increment use count
      const [updatedPersona] = await db.update(personas)
        .set({
          useCount: (existingPersona.useCount || 0) + 1,
          updatedAt: new Date(),
        })
        .where(eq(personas.personaId, personaId))
        .returning();

      return res.json({ success: true, useCount: updatedPersona.useCount });
    } catch (error) {
      console.error("Error incrementing persona use count:", error);
      return res.status(500).json({ error: "Failed to increment persona use count" });
    }
  });

  // API to recommend personas based on various factors
  app.get("/api/personas/recommend", async (req, res) => {
    try {
      // Get query parameters
      const timeOfDay = req.query.timeOfDay as string ||
                        (() => {
                          const hour = new Date().getHours();
                          if (hour >= 5 && hour < 12) return "morning";
                          if (hour >= 12 && hour < 17) return "afternoon";
                          if (hour >= 17 && hour < 21) return "evening";
                          return "night";
                        })();

      // Get emotion keywords from query if provided
      const emotions = req.query.emotions
                      ? (req.query.emotions as string).split(',')
                      : [];

      // Get all active personas
      const allPersonas = await db.query.personas.findMany({
        where: eq(personas.isActive, true)
      });

      // Score each persona based on recommendation factors
      const scoredPersonas = allPersonas.map(persona => {
        let score = 0;

        // Factor 1: Time of day match
        if (persona.timeOfDay === timeOfDay || persona.timeOfDay === "all") {
          score += 10;
        }

        // Factor 2: Emotional keyword match
        const personaEmotions = persona.emotionalKeywords as string[] || [];
        emotions.forEach(emotion => {
          if (personaEmotions.includes(emotion)) {
            score += 5;
          }
        });

        // Factor 3: Featured status
        if (persona.isFeatured) {
          score += 15;
        }

        // Factor 4: Popularity (use count)
        score += Math.min(persona.useCount || 0, 50) / 5;

        return { persona, score };
      });

      // Sort by score (descending) and return top results
      scoredPersonas.sort((a, b) => b.score - a.score);

      // Return top recommendations with scores
      return res.json({
        timeOfDay,
        emotions,
        recommendations: scoredPersonas.slice(0, 5).map(({ persona, score }) => ({
          id: persona.personaId,
          name: persona.name,
          avatarEmoji: persona.avatarEmoji,
          description: persona.description,
          score: Math.round(score),
          categories: persona.categories as string[] || [],
        }))
      });
    } catch (error) {
      console.error("Error getting persona recommendations:", error);
      return res.status(500).json({ error: "Failed to get persona recommendations" });
    }
  });

  // AI Image Generation Concept Management

  // Get all active concept categories (public endpoint)
  app.get("/api/concept-categories", async (req, res) => {
    try {
      const activeCategories = await db.select().from(conceptCategories)
        .where(eq(conceptCategories.isActive, true))
        .orderBy(asc(conceptCategories.order));
      return res.json(activeCategories);
    } catch (error) {
      console.error("Error fetching public concept categories:", error);
      return res.status(500).json({ error: "Failed to fetch concept categories" });
    }
  });


  // Get model capabilities - Public endpoint (no auth required)
  app.get("/api/model-capabilities", async (req, res) => {
    try {
      // ì‹œìŠ¤í…œ ì„¤ì •ì—ì„œ ì§€ì›í•˜ëŠ” AI ëª¨ë¸ ëª©ë¡ ë°˜í™˜
      const systemSettings = await getSystemSettings();
      const supportedModels = systemSettings.supportedAiModels as string[];
      
      console.log("[Model Capabilities] ì§€ì› ê°€ëŠ¥í•œ ëª¨ë¸ ëª©ë¡ ë°˜í™˜:", supportedModels);

      // ì§€ì›ë˜ëŠ” ëª¨ë¸ ëª©ë¡ì„ ê°ì²´ í˜•íƒœë¡œ ë°˜í™˜ (ì´ì „ API í˜¸í™˜ì„± ìœ ì§€)
      const modelCapabilities: Record<string, boolean> = {};
      supportedModels.forEach((model: string) => {
        modelCapabilities[model] = true;
      });

      return res.json(modelCapabilities);
    } catch (error) {
      console.error("Error fetching model capabilities:", error);
      
      // ì—ëŸ¬ ë°œìƒ ì‹œ ê¸°ë³¸ ëª¨ë¸ ëª©ë¡ ë°˜í™˜ (graceful fallback)
      const fallbackCapabilities = {
        "openai": true,
        "gemini": true
      };
      console.warn("[Model Capabilities] ì—ëŸ¬ë¡œ ì¸í•´ ê¸°ë³¸ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤:", fallbackCapabilities);
      
      return res.json(fallbackCapabilities);
    }
  });

  // Get all active concepts (public endpoint)
  app.get("/api/concepts", async (req, res) => {
    try {
      // ì‚¬ìš©ì ì¸ì¦ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì¿ í‚¤ ìš°ì„ , í—¤ë” ëŒ€ì•ˆ)
      let userHospitalId = null;
      let isAdmin = false;
      
      // ì¿ í‚¤ì—ì„œ ë¨¼ì € í™•ì¸ (ë¸Œë¼ìš°ì € ë¡œê·¸ì¸)
      let token = req.cookies?.auth_token;
      
      // Authorization í—¤ë”ì—ì„œ ëŒ€ì•ˆìœ¼ë¡œ í™•ì¸ (API í˜¸ì¶œ)
      if (!token) {
        const authHeader = req.headers.authorization;
        if (authHeader?.startsWith('Bearer ')) {
          token = authHeader.substring(7);
        }
      }

      if (token) {
        try {
          const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;

          const userId = decoded.userId || decoded.id;
          if (userId) {
            // ğŸ”¥ ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
            isAdmin = decoded.memberType === 'admin' || decoded.memberType === 'superadmin';
            
            console.log(`[ì»¨ì…‰ ì¡°íšŒ] ì‚¬ìš©ì ID: ${userId}, ê´€ë¦¬ì: ${isAdmin}, memberType: ${decoded.memberType}`);

            // ì¼ë°˜ ì‚¬ìš©ìì¸ ê²½ìš°ì—ë§Œ ë³‘ì› ë©¤ë²„ì‹­ í™•ì¸
            if (!isAdmin) {
              const hospitalMember = await db.query.hospitalMembers.findFirst({
                where: eq(hospitalMembers.userId, userId)
              });

              if (hospitalMember) {
                userHospitalId = hospitalMember.hospitalId;
                console.log(`[ì»¨ì…‰ ì¡°íšŒ] ì¼ë°˜ ì‚¬ìš©ìì˜ ë³‘ì› ID: ${userHospitalId}`);
              }
            }
          }
        } catch (error) {
          // í† í° ê²€ì¦ ì‹¤íŒ¨ì‹œ ê³µê°œ ì»¨ì…‰ë§Œ ë³´ì—¬ì¤Œ
          console.log('[ì»¨ì…‰ ì¡°íšŒ] JWT í† í° ê²€ì¦ ì‹¤íŒ¨:', error);
        }
      }

      // ğŸ¯ ì»¨ì…‰ í•„í„°ë§: ê´€ë¦¬ìë©´ ëª¨ë“  í™œì„±í™”ëœ ì»¨ì…‰, ì¼ë°˜ ì‚¬ìš©ìë©´ ê³µê°œ + ë³¸ì¸ ë³‘ì› ì „ìš©
      let whereConditions;
      
      if (isAdmin) {
        // ê´€ë¦¬ì: ëª¨ë“  í™œì„±í™”ëœ ì»¨ì…‰ (ê³µê°œ + ë³‘ì›ì „ìš© ëª¨ë‘)
        whereConditions = eq(concepts.isActive, true);
        console.log('[ì»¨ì…‰ ì¡°íšŒ] ê´€ë¦¬ì - ëª¨ë“  í™œì„±í™”ëœ ì»¨ì…‰ ë°˜í™˜');
      } else {
        // ì¼ë°˜ ì‚¬ìš©ì: ê³µê°œ + ë³¸ì¸ ì†Œì† ë³‘ì› ì „ìš©
        whereConditions = and(
          eq(concepts.isActive, true),
          or(
            eq(concepts.visibilityType, 'public'),
            userHospitalId ? and(
              eq(concepts.visibilityType, 'hospital'),
              eq(concepts.hospitalId, userHospitalId)
            ) : undefined
          )
        );
        console.log(`[ì»¨ì…‰ ì¡°íšŒ] ì¼ë°˜ ì‚¬ìš©ì - ê³µê°œ + ë³‘ì› ${userHospitalId} ì „ìš© ì»¨ì…‰ ë°˜í™˜`);
      }

      const activeConcepts = await db.select().from(concepts)
        .where(whereConditions)
        .orderBy(asc(concepts.order));

      // URL ë³€í™˜ í•¨ìˆ˜ - SignedURLì„ ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
      const convertToDirectUrl = (url: string): string => {
        if (!url) return url;
        try {
          // SignedURLì¸ ê²½ìš° ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
          if (url.includes('GoogleAccessId=') || url.includes('Signature=')) {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            if (pathname.includes('/createtree-upload/')) {
              const filePath = pathname.substring(pathname.indexOf('/createtree-upload/') + '/createtree-upload/'.length);
              return `https://storage.googleapis.com/createtree-upload/${filePath}`;
            }
          }
          // ì´ë¯¸ ì§ì ‘ URLì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
          return url;
        } catch (error) {
          return url;
        }
      };

      // ëª¨ë“  ì»¨ì…‰ì˜ ì¸ë„¤ì¼ URLì„ ì§ì ‘ ê³µê°œ URLë¡œ ë³€í™˜
      const convertedConcepts = activeConcepts.map(concept => ({
        ...concept,
        thumbnailUrl: concept.thumbnailUrl ? convertToDirectUrl(concept.thumbnailUrl) : concept.thumbnailUrl
      }));

      return res.json(convertedConcepts);
    } catch (error) {
      console.error("Error fetching public concepts:", error);
      return res.status(500).json({ error: "Failed to fetch concepts" });
    }
  });

  // ğŸ¯ ì»¨ì…‰ë³„ ë³€ìˆ˜ ì¡°íšŒ API (ê³µê°œ - ì‚¬ìš©ììš©)
  app.get("/api/concepts/:conceptId/variables", async (req, res) => {
    try {
      const { conceptId } = req.params;

      // í™œì„±í™”ëœ ì»¨ì…‰ë§Œ ì¡°íšŒ (ê³µê°œ APIì´ë¯€ë¡œ)
      const concept = await db.query.concepts.findFirst({
        where: and(
          eq(concepts.conceptId, conceptId),
          eq(concepts.isActive, true) // ğŸ”¥ í™œì„±í™”ëœ ì»¨ì…‰ë§Œ
        )
      });

      if (!concept) {
        return res.status(404).json({ error: "Active concept not found" });
      }

      // ë³€ìˆ˜ ì •ë³´ íŒŒì‹± ë° ë°˜í™˜
      let variables = [];
      if (concept.variables) {
        try {
          variables = typeof concept.variables === 'string'
            ? JSON.parse(concept.variables)
            : concept.variables;
        } catch (e) {
          console.log(`[ë³€ìˆ˜ ì¡°íšŒ] ${conceptId} ì»¨ì…‰ì˜ ë³€ìˆ˜ íŒŒì‹± ì‹¤íŒ¨`);
          variables = [];
        }
      }

      console.log(`[ë³€ìˆ˜ ì¡°íšŒ] ${conceptId} ì»¨ì…‰ ë³€ìˆ˜:`, variables);
      console.log(`[ë³€ìˆ˜ ì¡°íšŒ] ${conceptId} ë°˜í™˜í•  JSON:`, JSON.stringify(variables));

      return res.json(variables);
    } catch (error) {
      console.error("[ë³€ìˆ˜ ì¡°íšŒ] API ì—ëŸ¬:", error);
      return res.status(500).json({ error: "Failed to fetch concept variables" });
    }
  });



  // ì„œë¹„ìŠ¤ ì¹´í…Œê³ ë¦¬ API ì—”ë“œí¬ì¸íŠ¸

  // --- public menu (ì¹´í…Œê³ ë¦¬ + í•˜ìœ„ë©”ë‰´) --------------------------
  app.get("/api/menu", async (req, res) => {
    try {
      const rows = await db
        .select({
          categoryId: serviceCategories.id,
          categoryTitle: serviceCategories.title,
          categoryIcon: serviceCategories.icon,
          itemId: serviceItems.itemId,
          itemTitle: serviceItems.title,
          path: serviceItems.path,
          iconName: serviceItems.icon,
          order: serviceItems.order,
        })
        .from(serviceItems)
        .innerJoin(serviceCategories, eq(serviceItems.categoryId, serviceCategories.id))
        .where(eq(serviceItems.isPublic, true))
        .orderBy(serviceCategories.order, serviceItems.order);

      // ê° ì¹´í…Œê³ ë¦¬ë§ˆë‹¤ id, title, iconì„ í¬í•¨í•˜ëŠ” êµ¬ì¡°ë¡œ ë³€ê²½
      const grouped = Object.values(
        rows.reduce<Record<number, any>>((acc, r) => {
          if (!acc[r.categoryId]) {
            acc[r.categoryId] = {
              id: r.categoryId,
              title: r.categoryTitle,
              icon: r.categoryIcon || 'image', // ê¸°ë³¸ê°’ ì„¤ì •
              items: []
            };
          }
          acc[r.categoryId].items.push({
            id: r.itemId,
            title: r.itemTitle,
            path: r.path,
            iconName: r.iconName || 'layers', // ê¸°ë³¸ê°’ ì„¤ì •
          });
          return acc;
        }, {})
      );

      console.log("ë©”ë‰´ êµ¬ì¡°:", JSON.stringify(grouped));
      res.json(grouped);
    } catch (e) {
      console.error(e);
      res.status(500).json({ error: "menu-error" });
    }
  });

  // ê³µê°œ ì„œë¹„ìŠ¤ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ (ì¼ë°˜ ì‚¬ìš©ììš©)
  app.get("/api/service-categories", async (req, res) => {
    try {
      const publicCategories = await db.query.serviceCategories.findMany({
        where: eq(serviceCategories.isPublic, true),
        orderBy: [asc(serviceCategories.order), asc(serviceCategories.id)]
      });
      return res.json(publicCategories);
    } catch (error) {
      console.error("Error fetching public service categories:", error);
      return res.status(500).json({ error: "ì„œë¹„ìŠ¤ ì¹´í…Œê³ ë¦¬ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ì„œë¹„ìŠ¤ ì¹´í…Œê³ ë¦¬ API ì—”ë“œí¬ì¸íŠ¸ (ê´€ë¦¬ììš©)




  // ğŸ—‘ï¸ ê¸°ì¡´ ìŠ¤íƒ€ì¼ ì¹´ë“œ API ì œê±°ë¨ - ìƒˆë¡œìš´ ì»¨ì…‰ ê´€ë¦¬ ì‹œìŠ¤í…œ ì‚¬ìš©

  // Get active A/B test for a concept
  app.get("/api/concepts/:conceptId/abtest", async (req, res) => {
    try {
      const conceptId = req.params.conceptId;

      // Find active A/B test for the concept
      const activeTest = await db.query.abTests.findFirst({
        where: and(
          eq(abTests.conceptId, conceptId),
          eq(abTests.isActive, true)
        ),
      });

      if (!activeTest) {
        return res.status(404).json({ error: "No active A/B test found for this concept" });
      }

      // Get variants for the test
      const variants = await db.query.abTestVariants.findMany({
        where: eq(abTestVariants.testId, activeTest.testId),
      });

      return res.json({
        ...activeTest,
        variants
      });
    } catch (error) {
      console.error("Error fetching active A/B test:", error);
      return res.status(500).json({ error: "Failed to fetch active A/B test" });
    }
  });

  // ì±„íŒ… ê¸°ë¡ ë‚´ë³´ë‚´ê¸° - HTML í˜•ì‹
  app.get("/api/export/chat/html", async (req, res) => {
    try {
      const htmlContent = await exportChatHistoryAsHtml();

      // Set headers for file download
      res.setHeader('Content-Type', 'text/html');
      res.setHeader('Content-Disposition', 'attachment; filename="chat_history.html"');

      return res.send(htmlContent);
    } catch (error) {
      console.error("Error exporting chat history as HTML:", error);
      return res.status(500).json({ error: "Failed to export chat history" });
    }
  });

  // ì±„íŒ… ê¸°ë¡ ë‚´ë³´ë‚´ê¸° - í…ìŠ¤íŠ¸ í˜•ì‹
  app.get("/api/export/chat/text", async (req, res) => {
    try {
      const textContent = await exportChatHistoryAsHtml();

      // Set headers for file download
      res.setHeader('Content-Type', 'text/plain');
      res.setHeader('Content-Disposition', 'attachment; filename="chat_history.txt"');

      return res.send(textContent);
    } catch (error) {
      console.error("Error exporting chat history as text:", error);
      return res.status(500).json({ error: "Failed to export chat history" });
    }
  });

  // ë°°ë„ˆ ê´€ë¦¬ API
  app.get("/api/banners", async (req, res) => {
    try {
      const allBanners = await db.query.banners.findMany({
        where: eq(banners.isActive, true),
        orderBy: [asc(banners.sortOrder), desc(banners.createdAt)]
      });
      res.json(allBanners);
    } catch (error) {
      console.error("Error getting banners:", error);
      res.status(500).json({ error: "Failed to get banners" });
    }
  });

  // ê´€ë¦¬ììš© ë§ˆì¼ìŠ¤í†¤ API, ë°°ë„ˆ APIëŠ” admin-routes.tsë¡œ ì´ë™ë¨

  // ğŸ—‘ï¸ ê¸°ì¡´ ìŠ¤íƒ€ì¼ ì¹´ë“œ API ì œê±°ë¨ - ìƒˆë¡œìš´ ì»¨ì…‰ ê´€ë¦¬ ì‹œìŠ¤í…œ ì‚¬ìš©







  // ==================== ê´€ë¦¬ì ì „ìš© ë³‘ì› ê´€ë¦¬ API ====================
  // êµ¬ë²„ì „ ë³‘ì› ê´€ë¦¬ API ì œê±°ë¨ - admin-routes.tsì˜ /api/admin/hospitals ì‚¬ìš©

  // êµ¬ë²„ì „ ë³‘ì› CRUD API ì œê±°ë¨ - admin-routes.tsì˜ /api/admin/hospitals ì‚¬ìš©





  // ì¸ë„¤ì¼ ì´ë¯¸ì§€ ì—…ë¡œë“œ API, Service Categories/Items APIëŠ” admin-routes.tsë¡œ ì´ë™ë¨

  // Service Categories/Items public API endpoints
  app.get("/api/service-categories", async (req, res) => {
    try {
      const categories = await db.query.serviceCategories.findMany({
        orderBy: asc(serviceCategories.order)
      });

      res.json(categories);
    } catch (error) {
      console.error("Error fetching service categories:", error);
      res.status(500).json({ error: "Failed to fetch service categories" });
    }
  });

  app.get("/api/service-items", async (req, res) => {
    try {
      const { categoryId } = req.query;
      
      if (categoryId && typeof categoryId === 'string') {
        const categoryIdNum = parseInt(categoryId);
        if (!isNaN(categoryIdNum)) {
          const items = await db.select().from(serviceItems)
            .where(eq(serviceItems.categoryId, categoryIdNum))
            .orderBy(asc(serviceItems.order));
          return res.json(items);
        }
      }

      const items = await db.select().from(serviceItems).orderBy(asc(serviceItems.order));
      res.json(items);
    } catch (error) {
      console.error("Error fetching service items:", error);
      res.status(500).json({ error: "Failed to fetch service items" });
    }
  });


  // Gemini API í…ŒìŠ¤íŠ¸ ë¼ìš°í„° ë“±ë¡
  // app.use("/api/test-gemini", geminiTestRoutes); // ì œê±°ë¨
  console.log("Gemini API í…ŒìŠ¤íŠ¸ ë¼ìš°í„°ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤ (/api/test-gemini/*)");

  // ì„ì‹œ ë¼ìš°í„°ë“¤ ì œê±°ë¨ - í†µí•© ì¸ì¦ ì‹œìŠ¤í…œìœ¼ë¡œ ëŒ€ì²´



  // ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ ê´€ë¦¬ ë¼ìš°í„° ë“±ë¡



  // ğŸ—‘ï¸ ì´ë¯¸ì§€ ì‚­ì œ API (ë‹¨ìˆœ ë²„ì „)
  app.delete("/api/images/:id", requireAuth, async (req, res) => {
    try {
      const imageId = parseInt(req.params.id);
      const userId = req.user?.userId;

      console.log(`ğŸ—‘ï¸ ì´ë¯¸ì§€ ì‚­ì œ ìš”ì²­: ID=${imageId}, ì‚¬ìš©ì=${userId}`);

      if (!userId) {
        return res.status(401).json({ error: 'ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤' });
      }

      if (isNaN(imageId)) {
        return res.status(400).json({ error: 'ì˜ëª»ëœ ì´ë¯¸ì§€ IDì…ë‹ˆë‹¤' });
      }

      // ê¸°ì¡´ deleteImage í•¨ìˆ˜ ì‚¬ìš© 
      const result = await storage.deleteImage(imageId);
      console.log(`âœ… ì´ë¯¸ì§€ ì‚­ì œ ì„±ê³µ: ID=${imageId}`);

      res.json({ success: true, message: 'ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤' });
    } catch (error: any) {
      console.error(`âŒ ì´ë¯¸ì§€ ì‚­ì œ ì˜¤ë¥˜:`, error);
      res.status(500).json({ error: 'ì´ë¯¸ì§€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' });
    }
  });
  console.log("âœ… ì´ë¯¸ì§€ ì‚­ì œ APIê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤ (DELETE /api/images/:id)");

  // ìŒì•… ìŠ¤íŠ¸ë¦¬ë° APIëŠ” server/index.tsì—ì„œ ì²˜ë¦¬ë¨ (ì¤‘ë³µ ì œê±°)

  // Google OAuth2 ë¼ìš°í„° ë“±ë¡
  app.use("/api/google-oauth", googleOAuthRouter);
  console.log("Google OAuth2 ë¼ìš°í„°ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤ (/api/google-oauth/*)");
  console.log("ğŸ” Google OAuth2 ì„¤ì • í™•ì¸:", {
    CLIENT_ID: process.env.GOOGLE_CLIENT_ID ? 'ì„¤ì •ë¨' : 'ì—†ìŒ',
    CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET ? 'ì„¤ì •ë¨' : 'ì—†ìŒ'
  });

  // ğŸš¨ ì¤‘ë³µ ë¼ìš°í„° ì œê±°ë¨ - ìƒë‹¨ì˜ ìƒˆë¡œìš´ ë¼ìš°í„° ì‚¬ìš© (274ë²ˆ ì¤„)



  // ì¸ì¦ ì—†ëŠ” ë³‘ì› API ì œê±°ë¨ - admin-routes.tsì˜ /api/admin/hospitals ì‚¬ìš©

  // ìŠˆí¼ê´€ë¦¬ì API ë¼ìš°íŠ¸ ì¶”ê°€ (JWT ì¸ì¦ ë°©ì‹)
  app.get("/api/super/hospitals", async (req, res) => {
    try {
      // JWT í† í°ì—ì„œ ì‚¬ìš©ì ì •ë³´ í™•ì¸
      const userData = req.user as any;

      if (!userData || !userData.userId) {
        return res.status(401).json({ error: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.' });
      }

      // ì‹¤ì œ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
      const { users } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      const user = await db.query.users.findFirst({
        where: eq(users.id, userData.userId),
      });

      if (!user) {
        return res.status(401).json({ error: 'ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' });
      }

      if (user.memberType !== 'superadmin') {
        return res.status(403).json({ error: 'ìŠˆí¼ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.' });
      }

      const { hospitals } = await import("@shared/schema");
      const { desc } = await import("drizzle-orm");

      const hospitalsList = await db.query.hospitals.findMany({
        orderBy: [desc(hospitals.createdAt)]
      });
      return res.status(200).json(hospitalsList);
    } catch (error) {
      console.error('ë³‘ì› ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
      return res.status(500).json({ error: 'ë³‘ì› ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' });
    }
  });

  // ì¸ì¦ ì—†ëŠ” ì¤‘ë³µ ë³‘ì› CRUD API ì œê±°ë¨ - admin-routes.tsì˜ ì¸ì¦ëœ API ì‚¬ìš©

  // ì¤‘ë³µëœ ë¼ìš°í„° ì œê±°ë¨ - ì²« ë²ˆì§¸ ë¼ìš°í„°ë¡œ í†µí•©

  // ì´ë¯¸ì§€ ë¼ìš°í„° ë“±ë¡ - /apiì— ë§ˆìš´íŠ¸í•˜ì—¬ ëª¨ë“  ì´ë¯¸ì§€ ê´€ë ¨ ê²½ë¡œ ì²˜ë¦¬
  app.use('/api', imageRouter);

  // ğŸ—‘ï¸ ë³µì¡í•œ ìŠ¤íƒ€ì¼ì¹´ë“œ ìƒì„± APIë“¤ ì™„ì „íˆ ì œê±°ë¨

  // ì•Œë¦¼ ì„¤ì • API
  app.get("/api/notification-settings", requireAuth, async (req, res) => {
    try {
      console.log("ì•Œë¦¼ ì„¤ì • ì¡°íšŒ ìš”ì²­ - req.user:", req.user);
      // JWTì—ì„œ userId ì¶”ì¶œí•˜ê³  ìˆ«ìë¡œ ë³€í™˜
      const userIdRaw = req.user!.userId || req.user!.id || req.user!.sub;
      const userId = Number(userIdRaw);
      console.log("ì¡°íšŒìš© userId:", userId, "íƒ€ì…:", typeof userId);
      const { userNotificationSettings } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      const settings = await db.query.userNotificationSettings.findFirst({
        where: eq(userNotificationSettings.userId, userId)
      });

      if (!settings) {
        // ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ìƒˆ ë ˆì½”ë“œ ìƒì„±
        const [newSettings] = await db.insert(userNotificationSettings)
          .values({
            userId,
            emailNotifications: true,
            pushNotifications: false,
            pregnancyReminders: true,
            weeklyUpdates: true,
            promotionalEmails: false,
          })
          .returning();

        return res.json({ success: true, settings: newSettings });
      }

      return res.json({ success: true, settings });
    } catch (error) {
      console.error("ì•Œë¦¼ ì„¤ì • ì¡°íšŒ ì˜¤ë¥˜:", error);
      return res.status(500).json({
        success: false,
        message: "ì•Œë¦¼ ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
      });
    }
  });

  app.put("/api/notification-settings", requireAuth, async (req, res) => {
    try {
      console.log("ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸ ìš”ì²­ - req.user:", req.user);
      // JWTì—ì„œ userId ì¶”ì¶œí•˜ê³  ìˆ«ìë¡œ ë³€í™˜
      const userIdRaw = req.user!.userId || req.user!.id || req.user!.sub;
      const userId = Number(userIdRaw);
      console.log("ì¶”ì¶œëœ userId:", userId, "íƒ€ì…:", typeof userId);
      const { emailNotifications, pushNotifications, pregnancyReminders, weeklyUpdates, promotionalEmails } = req.body;

      const { userNotificationSettings } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      const existingSettings = await db.query.userNotificationSettings.findFirst({
        where: eq(userNotificationSettings.userId, userId)
      });

      let updatedSettings;

      if (existingSettings) {
        [updatedSettings] = await db.update(userNotificationSettings)
          .set({
            emailNotifications,
            pushNotifications,
            pregnancyReminders,
            weeklyUpdates,
            promotionalEmails,
            updatedAt: new Date(),
          })
          .where(eq(userNotificationSettings.userId, userId))
          .returning();
      } else {
        [updatedSettings] = await db.insert(userNotificationSettings)
          .values({
            userId,
            emailNotifications,
            pushNotifications,
            pregnancyReminders,
            weeklyUpdates,
            promotionalEmails,
          })
          .returning();
      }

      return res.json({ success: true, settings: updatedSettings });
    } catch (error) {
      console.error("ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:", error);
      return res.status(500).json({
        success: false,
        message: "ì•Œë¦¼ ì„¤ì •ì„ ì €ì¥í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
      });
    }
  });

  // ì‚¬ìš©ì ì„¤ì • API
  app.get("/api/user-settings", requireAuth, async (req, res) => {
    try {
      console.log("ì‚¬ìš©ì ì„¤ì • ì¡°íšŒ ìš”ì²­ - req.user:", req.user);
      const userIdRaw = req.user!.userId || req.user!.id || req.user!.sub;
      const userId = Number(userIdRaw);
      console.log("ì¶”ì¶œëœ userId:", userId, "íƒ€ì…:", typeof userId);

      const { userSettings } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      let settings = await db.query.userSettings.findFirst({
        where: eq(userSettings.userId, userId)
      });

      // ì„¤ì •ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì„¤ì • ìƒì„±
      if (!settings) {
        console.log("ì‚¬ìš©ì ì„¤ì •ì´ ì—†ì–´ì„œ ê¸°ë³¸ ì„¤ì • ìƒì„±");
        const [newSettings] = await db.insert(userSettings).values({
          userId,
          theme: "light",
          language: "ko",
          timezone: "Asia/Seoul",
          dateFormat: "YYYY-MM-DD",
          autoSave: true,
          showTutorials: true,
        }).returning();
        settings = newSettings;
      }

      res.json({
        success: true,
        settings
      });
    } catch (error) {
      console.error("ì‚¬ìš©ì ì„¤ì • ì¡°íšŒ ì˜¤ë¥˜:", error);
      res.status(500).json({
        success: false,
        message: "ì‚¬ìš©ì ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
      });
    }
  });

  app.put("/api/user-settings", requireAuth, async (req, res) => {
    try {
      console.log("ì‚¬ìš©ì ì„¤ì • ì—…ë°ì´íŠ¸ ìš”ì²­ - req.user:", req.user);
      const userIdRaw = req.user!.userId || req.user!.id || req.user!.sub;
      const userId = Number(userIdRaw);
      console.log("ì¶”ì¶œëœ userId:", userId, "íƒ€ì…:", typeof userId);

      const { theme, language, timezone, dateFormat, autoSave, showTutorials } = req.body;

      const { userSettings } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      const existingSettings = await db.query.userSettings.findFirst({
        where: eq(userSettings.userId, userId)
      });

      let updatedSettings;

      if (existingSettings) {
        [updatedSettings] = await db.update(userSettings)
          .set({
            theme,
            language,
            timezone,
            dateFormat,
            autoSave,
            showTutorials,
            updatedAt: new Date(),
          })
          .where(eq(userSettings.userId, userId))
          .returning();
      } else {
        [updatedSettings] = await db.insert(userSettings).values({
          userId,
          theme,
          language,
          timezone,
          dateFormat,
          autoSave,
          showTutorials,
        }).returning();
      }

      res.json({
        success: true,
        settings: updatedSettings
      });
    } catch (error) {
      console.error("ì‚¬ìš©ì ì„¤ì • ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:", error);
      res.status(500).json({
        success: false,
        message: "ì„¤ì •ì„ ì €ì¥í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
      });
    }
  });


  // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ í”„ë¡ì‹œ API (CORS ë¬¸ì œ í•´ê²°)
  app.get("/api/download-image/:imageId", requireAuth, async (req, res) => {
    try {
      const { imageId } = req.params;
      const userId = req.user!.userId;
      const { images } = await import("@shared/schema");
      const { eq, and } = await import("drizzle-orm");

      // ì‚¬ìš©ìê°€ ì†Œìœ í•œ ì´ë¯¸ì§€ì¸ì§€ í™•ì¸
      const image = await db.query.images.findFirst({
        where: and(
          eq(images.id, parseInt(imageId)),
          eq(images.userId, String(userId))
        )
      });

      if (!image) {
        return res.status(404).json({
          success: false,
          message: "ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        });
      }

      const imageUrl = image.transformedUrl || image.originalUrl;
      console.log(`[ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ] ì‚¬ìš©ì ${userId}ê°€ ì´ë¯¸ì§€ ${imageId} ë‹¤ìš´ë¡œë“œ ìš”ì²­:`, imageUrl);

      // ì´ë¯¸ì§€ URLì´ GCS URLì¸ì§€ í™•ì¸
      if (imageUrl.includes('storage.googleapis.com')) {
        // GCSì—ì„œ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
        const fetch = (await import('node-fetch')).default;
        const response = await fetch(imageUrl);

        if (!response.ok) {
          throw new Error(`ì´ë¯¸ì§€ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${response.status}`);
        }

        const buffer = await response.buffer();
        const fileName = (image.title || 'image').replace(/\.(jpg|jpeg|png|webp)$/i, '') + '.webp';

        res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(fileName)}"`);
        res.setHeader('Content-Type', 'image/webp');
        res.setHeader('Content-Length', buffer.length);

        return res.send(buffer);
      } else {
        // ë¡œì»¬ íŒŒì¼ì¸ ê²½ìš°
        const fs = await import('fs');
        const path = await import('path');

        const filePath = path.join(process.cwd(), 'static', imageUrl.replace('/static/', ''));

        if (!fs.existsSync(filePath)) {
          return res.status(404).json({
            success: false,
            message: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
          });
        }

        const fileName = (image.title || 'image').replace(/\.(jpg|jpeg|png|webp)$/i, '') + '.webp';
        res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(fileName)}"`);

        return res.sendFile(filePath);
      }
    } catch (error) {
      console.error("ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:", error);
      return res.status(500).json({
        success: false,
        message: "ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
      });
    }
  });


  // ìŒì•… ìŠ¤íƒ€ì¼ APIëŠ” /api/music-engine ë¼ìš°í„°ì—ì„œ ì²˜ë¦¬ë¨ (ì¤‘ë³µ ì œê±°)

  // ìŒì•… ì—”ì§„ APIëŠ” /api/music-engine ë¼ìš°í„°ì—ì„œ ì²˜ë¦¬ë¨ (ì¤‘ë³µ ì œê±°)

  // ìŒì•… ì—”ì§„ ìƒíƒœ APIëŠ” /api/music-engine ë¼ìš°í„°ì—ì„œ ì²˜ë¦¬ë¨ (ì¤‘ë³µ ì œê±°)

  // ìŒì•… ì—”ì§„ ìŠ¤íƒ€ì¼ APIëŠ” /api/music-engine ë¼ìš°í„°ì—ì„œ ì²˜ë¦¬ë¨ (ì¤‘ë³µ ì œê±°)

  // ==================== ìŒì•… ê°¤ëŸ¬ë¦¬ ê´€ë¦¬ API ====================
  // ìŒì•… ê´€ë¦¬ APIëŠ” admin-routes.tsë¡œ ì´ë™ë¨

  // í†µí•© ìŒì•… ì—”ì§„ API ë¼ìš°íŠ¸ ë“±ë¡
  app.use('/api/music-engine', musicEngineRouter);
  app.use('/api/music', musicEngineRouter); // ê¸°ì¡´ /api/music ê²½ë¡œ í˜¸í™˜ì„± ìœ ì§€

  // Chat API ë¼ìš°íŠ¸ ë“±ë¡
  app.use('/api/chat', chatRoutes);

  // ë°°ë„ˆ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¼ìš°í„° ë“±ë¡ - ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥
  app.use('/api/admin/banner-migration', bannerMigrationRouter);

  // ì½œë¼ì£¼ ë¼ìš°í„° ë“±ë¡ - ì¸ì¦ëœ ì‚¬ìš©ìë§Œ ì ‘ê·¼ ê°€ëŠ¥
  app.use('/api/collage', (req, res, next) => {
    // requireAuth ë¯¸ë“¤ì›¨ì–´ ì‹¤í–‰
    requireAuth(req, res, (err?: any) => {
      if (err) return next(err);
      // collage ë¼ìš°í„°ë¡œ ì „ë‹¬
      collageRouter(req, res, next);
    });
  });
  console.log('ğŸ“¸ ì½œë¼ì£¼ ë¼ìš°í„°ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤ (/api/collage/*) - ì¸ì¦ í•„ìˆ˜');

  // ì •ì  íŒŒì¼ ì„œë¹™ ì„¤ì • - ì´ë¯¸ì§€ í‘œì‹œë¥¼ ìœ„í•´ í•„ìˆ˜
  app.use('/uploads', express.static(path.join(process.cwd(), 'public', 'uploads')));
  app.use('/static', express.static(path.join(process.cwd(), 'static')));

  // ì „ì—­ ë¯¸ë“¤ì›¨ì–´ ë“±ë¡ (ëª¨ë“  ë¼ìš°íŠ¸ì— ì ìš©)
  app.use(requestLogger);
  app.use(responseFormatter);

  // ì „ì—­ ì—ëŸ¬ í•¸ë“¤ë§ ë¯¸ë“¤ì›¨ì–´ (ë§ˆì§€ë§‰ì— ë“±ë¡)
  app.use(errorHandler);

  // ğŸŒ GCS ì´ë¯¸ì§€ ê´€ë¦¬ APIëŠ” admin-routes.tsë¡œ ì´ë™ë¨

  // ===== Phase 5: ì•Œë¦¼ ì‹œìŠ¤í…œ API ì—”ë“œí¬ì¸íŠ¸ (ê¸°ë³¸ êµ¬í˜„) =====

  // ì•Œë¦¼ ì‹œìŠ¤í…œ ê¸°ë³¸ API
  app.get("/api/notifications", async (req, res) => {
    res.json({
      success: true,
      message: "Phase 5 ì•Œë¦¼ ì‹œìŠ¤í…œì´ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤.",
      notifications: [],
      unreadCount: 0
    });
  });

  // í…ŒìŠ¤íŠ¸ìš© ìŠ¤í‚¤ë§ˆ í™•ì¸ ì—”ë“œí¬ì¸íŠ¸
  app.get('/api/test/schema/:tableName', async (req: Request, res: express.Response) => {
    try {
      const { tableName } = req.params;

      if (tableName === 'milestone_application_files') {
        // milestoneApplicationFiles í…Œì´ë¸” ìŠ¤í‚¤ë§ˆ ì •ë³´ ë°˜í™˜
        const schema = {
          tableName: 'milestone_application_files',
          columns: [
            { name: 'id', type: 'serial', nullable: false },
            { name: 'applicationId', type: 'integer', nullable: false },
            { name: 'fileName', type: 'text', nullable: false },
            { name: 'originalName', type: 'text', nullable: false },
            { name: 'mimeType', type: 'text', nullable: false },
            { name: 'fileSize', type: 'integer', nullable: false },
            { name: 'filePath', type: 'text', nullable: false },
            { name: 'description', type: 'text', nullable: true },
            { name: 'uploadedAt', type: 'timestamp', nullable: false },
            { name: 'uploadedBy', type: 'integer', nullable: false },
            { name: 'isDeleted', type: 'boolean', nullable: false, default: false }
          ]
        };

        res.json(schema);
      } else {
        res.status(404).json({ error: 'Table not found or not supported' });
      }
    } catch (error) {
      res.status(500).json({ error: 'Schema query failed' });
    }
  });

  // í…ŒìŠ¤íŠ¸ìš© Multer ì„¤ì • í™•ì¸ ì—”ë“œí¬ì¸íŠ¸
  app.get('/api/test/multer-config', async (req: Request, res: express.Response) => {
    try {
      // Multer ì„¤ì •ì´ ì˜¬ë°”ë¥¸ì§€ í™•ì¸
      const multerConfig = {
        configured: true,
        maxFileSize: '10MB',
        allowedTypes: ['image/jpeg', 'image/png', 'image/gif', 'application/pdf', 'text/plain', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
        uploadDirectory: 'uploads/'
      };

      res.json(multerConfig);
    } catch (error) {
      res.status(500).json({ error: 'Multer configuration check failed' });
    }
  });

  // ==================== Phase 7-1: ê´€ë¦¬ì ì‹ ì²­ ë‚´ì—­ ê´€ë¦¬ API
  // ====================

  // ê´€ë¦¬ì - ì‹ ì²­ ëª©ë¡ ì¡°íšŒ (ìƒíƒœë³„ í•„í„°ë§ ì§€ì›)
  app.get('/api/admin/milestone-applications', requireAuth, async (req: Request, res: express.Response) => {
    try {
      const userId = validateUserId(req, res);
      if (!userId) return;

      // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
      const user = await db.query.users.findFirst({
        where: eq(users.id, Number(userId))
      });

      if (!user || !['admin', 'superadmin'].includes(user.memberType || '')) {
        return res.status(403).json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤." });
      }

      const { status } = req.query;

      // ì‹ ì²­ ëª©ë¡ ì¡°íšŒ with ì¡°ì¸
      let applicationsQuery = db.query.milestoneApplications.findMany({
        with: {
          milestone: {
            with: {
              category: true
            }
          },
          user: {
            columns: {
              id: true,
              username: true,
              email: true
            }
          },
          files: true
        },
        orderBy: (milestoneApplications, { desc }) => [desc(milestoneApplications.appliedAt)]
      });

      let applications;
      if (status && status !== 'all') {
        applications = await db.query.milestoneApplications.findMany({
          where: eq(milestoneApplications.status, status as string),
          with: {
            milestone: {
              with: {
                category: true
              }
            },
            user: {
              columns: {
                id: true,
                username: true,
                email: true
              }
            },
            files: true
          },
          orderBy: (milestoneApplications, { desc }) => [desc(milestoneApplications.appliedAt)]
        });
      } else {
        applications = await applicationsQuery;
      }

      console.log(`âœ… ê´€ë¦¬ì ì‹ ì²­ ë‚´ì—­ ì¡°íšŒ ì„±ê³µ: ${applications.length}ê°œ`);
      res.json(applications);

    } catch (error) {
      console.error("âŒ ê´€ë¦¬ì ì‹ ì²­ ë‚´ì—­ ì¡°íšŒ ì˜¤ë¥˜:", error);
      res.status(500).json({ error: "ì‹ ì²­ ë‚´ì—­ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ê´€ë¦¬ì - ì‹ ì²­ ìƒì„¸ ì¡°íšŒ
  app.get('/api/admin/milestone-applications/:id', requireAuth, async (req: Request, res: express.Response) => {
    try {
      const userId = validateUserId(req, res);
      if (!userId) return;

      // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
      const user = await db.query.users.findFirst({
        where: eq(users.id, Number(userId))
      });

      if (!user || !['admin', 'superadmin'].includes(user.memberType || '')) {
        return res.status(403).json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤." });
      }

      const applicationId = parseInt(req.params.id);

      const application = await db.query.milestoneApplications.findFirst({
        where: eq(milestoneApplications.id, applicationId),
        with: {
          milestone: {
            with: {
              category: true
            }
          },
          user: {
            columns: {
              id: true,
              username: true,
              email: true,
              memberType: true
            }
          },
          files: true
        }
      });

      if (!application) {
        return res.status(404).json({ error: "ì‹ ì²­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." });
      }

      console.log(`âœ… ê´€ë¦¬ì ì‹ ì²­ ìƒì„¸ ì¡°íšŒ ì„±ê³µ: ${applicationId}`);
      res.json(application);

    } catch (error) {
      console.error("âŒ ê´€ë¦¬ì ì‹ ì²­ ìƒì„¸ ì¡°íšŒ ì˜¤ë¥˜:", error);
      res.status(500).json({ error: "ì‹ ì²­ ìƒì„¸ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ê´€ë¦¬ì - ì‹ ì²­ ìŠ¹ì¸/ê±°ì ˆ ì²˜ë¦¬
  app.patch('/api/admin/milestone-applications/:id/status', requireAuth, async (req: Request, res: express.Response) => {
    try {
      const userId = validateUserId(req, res);
      if (!userId) return;

      // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
      const user = await db.query.users.findFirst({
        where: eq(users.id, Number(userId))
      });

      if (!user || !['admin', 'superadmin'].includes(user.memberType || '')) {
        return res.status(403).json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤." });
      }

      const applicationId = parseInt(req.params.id);
      const { status, notes } = req.body;

      // ìœ íš¨í•œ ìƒíƒœ í™•ì¸
      if (!['approved', 'rejected', 'cancelled'].includes(status)) {
        return res.status(400).json({ error: "ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœì…ë‹ˆë‹¤." });
      }

      // ê¸°ì¡´ ì‹ ì²­ í™•ì¸
      const existingApplication = await db.query.milestoneApplications.findFirst({
        where: eq(milestoneApplications.id, applicationId)
      });

      if (!existingApplication) {
        return res.status(404).json({ error: "ì‹ ì²­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." });
      }

      // ì²˜ë¦¬ ê°€ëŠ¥í•œ ìƒíƒœ í™•ì¸
      if (status === 'cancelled') {
        // ìŠ¹ì¸ ì·¨ì†ŒëŠ” approved ìƒíƒœì—ì„œë§Œ ê°€ëŠ¥
        if (existingApplication.status !== 'approved') {
          return res.status(400).json({ error: "ìŠ¹ì¸ëœ ì‹ ì²­ë§Œ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." });
        }
      } else {
        // ìŠ¹ì¸/ê±°ì ˆì€ pending ìƒíƒœì—ì„œë§Œ ê°€ëŠ¥
        if (existingApplication.status !== 'pending') {
          return res.status(400).json({ error: "ëŒ€ê¸° ì¤‘ì¸ ì‹ ì²­ë§Œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." });
        }
      }

      // ìƒíƒœ ì—…ë°ì´íŠ¸
      await db.update(milestoneApplications)
        .set({
          status: status,
          notes: notes || null,
          processedAt: new Date(),
          processedBy: parseInt(userId)
        })
        .where(eq(milestoneApplications.id, applicationId));

      // ì•Œë¦¼ ìƒì„± (Phase 5ì—ì„œ êµ¬í˜„í•œ ì‹œìŠ¤í…œ ì‚¬ìš©)
      try {
        const getNotificationData = (status: string) => {
          switch (status) {
            case 'approved':
              return {
                type: 'application_approved',
                title: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ ìŠ¹ì¸',
                message: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ì´ ìŠ¹ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.'
              };
            case 'rejected':
              return {
                type: 'application_rejected',
                title: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ ê±°ì ˆ',
                message: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ì´ ê±°ì ˆë˜ì—ˆìŠµë‹ˆë‹¤.'
              };
            case 'cancelled':
              return {
                type: 'application_cancelled',
                title: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ ìŠ¹ì¸ ì·¨ì†Œ',
                message: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ ìŠ¹ì¸ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.'
              };
            default:
              return {
                type: 'application_status_changed',
                title: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ ìƒíƒœ ë³€ê²½',
                message: 'ë§ˆì¼ìŠ¤í†¤ ì‹ ì²­ ìƒíƒœê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.'
              };
          }
        };

        const notificationInfo = getNotificationData(status);
        const notificationData = {
          userId: existingApplication.userId,
          type: notificationInfo.type,
          title: notificationInfo.title,
          message: notificationInfo.message,
          relatedId: applicationId.toString(),
          relatedType: 'milestone_application'
        };

        await fetch(`http://localhost:${process.env.PORT || 5000}/api/notifications`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': req.headers.authorization || ''
          },
          body: JSON.stringify(notificationData)
        });
      } catch (notificationError) {
        console.error("ì•Œë¦¼ ìƒì„± ì‹¤íŒ¨:", notificationError);
        // ì•Œë¦¼ ì‹¤íŒ¨í•´ë„ í•µì‹¬ ê¸°ëŠ¥ì€ ê³„ì† ì§„í–‰
      }

      console.log(`âœ… ê´€ë¦¬ì ì‹ ì²­ ì²˜ë¦¬ ì„±ê³µ: ${applicationId} â†’ ${status}`);
      const statusMessage = status === 'approved' ? 'ìŠ¹ì¸' : status === 'rejected' ? 'ê±°ì ˆ' : 'ì·¨ì†Œ';
      res.json({
        success: true,
        message: `ì‹ ì²­ì´ ${statusMessage}ë˜ì—ˆìŠµë‹ˆë‹¤.`
      });

    } catch (error) {
      console.error("âŒ ê´€ë¦¬ì ì‹ ì²­ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      res.status(500).json({ error: "ì‹ ì²­ ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ê´€ë¦¬ì - ì‹ ì²­ í†µê³„ ì¡°íšŒ
  app.get('/api/admin/milestone-applications/stats', requireAuth, async (req: Request, res: express.Response) => {
    try {
      const userId = validateUserId(req, res);
      if (!userId) return;

      // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
      const user = await db.query.users.findFirst({
        where: eq(users.id, Number(userId))
      });

      if (!user || !['admin', 'superadmin'].includes(user.memberType || '')) {
        return res.status(403).json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤." });
      }

      // ìƒíƒœë³„ í†µê³„ ì¡°íšŒ
      const allApplications = await db.query.milestoneApplications.findMany();

      const stats = {
        total: allApplications.length,
        pending: allApplications.filter(app => app.status === 'pending').length,
        approved: allApplications.filter(app => app.status === 'approved').length,
        rejected: allApplications.filter(app => app.status === 'rejected').length,
        cancelled: allApplications.filter(app => app.status === 'cancelled').length,
        expired: allApplications.filter(app => app.status === 'expired').length,
        thisMonth: allApplications.filter(app => {
          const month = new Date().getMonth();
          const year = new Date().getFullYear();
          const appMonth = new Date(app.appliedAt).getMonth();
          const appYear = new Date(app.appliedAt).getFullYear();
          return appMonth === month && appYear === year;
        }).length
      };

      console.log(`âœ… ê´€ë¦¬ì ì‹ ì²­ í†µê³„ ì¡°íšŒ ì„±ê³µ:`, stats);
      res.json(stats);

    } catch (error) {
      console.error("âŒ ê´€ë¦¬ì ì‹ ì²­ í†µê³„ ì¡°íšŒ ì˜¤ë¥˜:", error);
      res.status(500).json({ error: "ì‹ ì²­ í†µê³„ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ë§ˆì¼ìŠ¤í†¤ í—¤ë” ì´ë¯¸ì§€ ì—…ë¡œë“œ API
  app.post('/api/admin/milestones/upload-header', requireAuth, milestoneUpload.single('headerImage'), (req: Request, res: express.Response) => {
    try {
      const userId = validateUserId(req, res);
      if (!userId) return;

      // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸ (ê°„ë‹¨í•œ í™•ì¸)
      // ì—¬ê¸°ì„œëŠ” íŒŒì¼ ì—…ë¡œë“œë§Œ ì²˜ë¦¬í•˜ê³ , ì‹¤ì œ ê´€ë¦¬ì ê¶Œí•œì€ ë§ˆì¼ìŠ¤í†¤ ìƒì„±/ìˆ˜ì • ì‹œ í™•ì¸

      if (!req.file) {
        return res.status(400).json({ error: "ì´ë¯¸ì§€ íŒŒì¼ì´ í•„ìš”í•©ë‹ˆë‹¤." });
      }

      // ì—…ë¡œë“œëœ íŒŒì¼ì˜ ìƒëŒ€ ê²½ë¡œ ë°˜í™˜ (static/milestones/ ì œê±°)
      const relativePath = `/static/milestones/${req.file.filename}`;

      console.log(`âœ… ë§ˆì¼ìŠ¤í†¤ í—¤ë” ì´ë¯¸ì§€ ì—…ë¡œë“œ ì„±ê³µ: ${relativePath}`);

      res.json({
        success: true,
        imageUrl: relativePath,
        filename: req.file.filename,
        originalName: req.file.originalname
      });

    } catch (error) {
      console.error("âŒ ë§ˆì¼ìŠ¤í†¤ í—¤ë” ì´ë¯¸ì§€ ì—…ë¡œë“œ ì˜¤ë¥˜:", error);
      res.status(500).json({ error: "ì´ë¯¸ì§€ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ========== OpenAI API í…ŒìŠ¤íŠ¸ ë¼ìš°íŠ¸ ==========
  app.post('/api/test-openai', async (req, res) => {
    try {
      const apiKey = process.env.OPENAI_API_KEY;
      const keyExists = !!apiKey;
      const keyPrefix = apiKey ? apiKey.substring(0, 7) + "..." : "ì—†ìŒ";
      const keyType = apiKey?.startsWith('sk-proj-') ? 'Project Key' : apiKey?.startsWith('sk-') ? 'Standard Key' : 'Invalid';

      console.log("ğŸ”‘ API í‚¤ ìƒíƒœ í™•ì¸:");
      console.log("  - í‚¤ ì¡´ì¬:", keyExists);
      console.log("  - í‚¤ ì ‘ë‘ì‚¬:", keyPrefix);
      console.log("  - í‚¤ íƒ€ì…:", keyType);

      // ê°„ë‹¨í•œ API í˜¸ì¶œ í…ŒìŠ¤íŠ¸ (í• ë‹¹ëŸ‰ ì†Œëª¨ ìµœì†Œí™”)
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          method: "GET",
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          }
        });

        const statusCode = response.status;

        if (response.ok) {
          console.log("âœ… OpenAI API ì—°ê²° ì„±ê³µ");
          res.json({
            success: true,
            apiKeyStatus: "valid",
            keyPrefix,
            keyType,
            apiResponse: "ì—°ê²° ì„±ê³µ"
          });
        } else {
          const errorData = await response.text();
          console.log("âŒ OpenAI API ì˜¤ë¥˜:", statusCode, errorData);
          res.json({
            success: false,
            apiKeyStatus: "error",
            keyPrefix,
            keyType,
            statusCode,
            error: errorData
          });
        }
      } catch (apiError) {
        console.log("âŒ API í˜¸ì¶œ ì‹¤íŒ¨:", apiError);
        res.json({
          success: false,
          apiKeyStatus: "connection_failed",
          keyPrefix,
          keyType,
          error: String(apiError)
        });
      }
    } catch (error) {
      console.error("í…ŒìŠ¤íŠ¸ ì—”ë“œí¬ì¸íŠ¸ ì˜¤ë¥˜:", error);
      res.status(500).json({ success: false, error: "í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨" });
    }
  });

  // ========== Pollo AI í…ŒìŠ¤íŠ¸ ë¼ìš°íŠ¸ ==========
  // Phase 1: API ì‘ë™ ê²€ì¦ì„ ìœ„í•œ ì„ì‹œ í…ŒìŠ¤íŠ¸ ì—”ë“œí¬ì¸íŠ¸
  app.post("/api/test/pollo-image", async (req, res) => {
    try {
      // USE_POLLO_API í™˜ê²½ë³€ìˆ˜ í™•ì¸
      const usePolloApi = process.env.USE_POLLO_API === 'true';

      if (!usePolloApi) {
        return res.status(400).json({
          error: "Pollo API is not enabled. Set USE_POLLO_API=true to test."
        });
      }

      const { prompt } = req.body;

      if (!prompt) {
        return res.status(400).json({ error: "Prompt is required" });
      }

      console.log(`[Pollo Test] ì´ë¯¸ì§€ ìƒì„± í…ŒìŠ¤íŠ¸ ì‹œì‘: ${prompt}`);

      // Pollo ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
      const { generateImageWithPollo } = await import("./services/pollo-service");

      // Pollo APIë¡œ ì´ë¯¸ì§€ ìƒì„±
      const imageUrl = await generateImageWithPollo(prompt);

      console.log(`[Pollo Test] ì´ë¯¸ì§€ ìƒì„± ì„±ê³µ: ${imageUrl}`);

      return res.json({
        success: true,
        message: "Pollo API test successful",
        imageUrl,
        prompt,
        engine: "pollo"
      });

    } catch (error) {
      console.error("[Pollo Test] ì˜¤ë¥˜:", error);
      return res.status(500).json({
        error: "Pollo API test failed",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  });

  const httpServer = createServer(app);

  return httpServer;
}