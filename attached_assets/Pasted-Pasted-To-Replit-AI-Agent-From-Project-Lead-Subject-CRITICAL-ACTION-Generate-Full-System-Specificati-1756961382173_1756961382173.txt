Pasted-To-Replit-AI-Agent-From-Project-Lead-Subject-CRITICAL-ACTION-Generate-Full-System-Specification-1756956231006_1756956231006.txtTo: Replit AI Agent From: Project Lead Subject: [CRITICAL ACTION] Generate Full System Specification for Project Rebuild

현재 프로젝트의 전체 소스 코드와 파일을 분석하여, 프로젝트를 처음부터 다시 구축(rebuild)하는 데 필요한 모든 정보가 포함된 **'종합 시스템 아키텍처 및 로직 명세서'**를 마크다운(Markdown) 형식으로 생성한다. 이 명세서는 새로운 프로젝트의 유일한 설계 청사진(Blueprint)으로 사용될 것이다.

반복적이고 근본적인 빌드 및 타입 오류로 인해, 현재 코드베이스를 점진적으로 수정하는 대신 완전한 재구축을 결정했다. 당신의 임무는 현재 시스템의 작동 방식을 100% 이해하고, 그 모든 정보를 사람이 읽을 수 있는 상세한 기술 문서로 추출하는 것이다. 추측이나 요약은 금지하며, 코드에 명시된 사실만을 기반으로 문서를 작성해야 한다.

역할: 당신은 이 프로젝트를 인수인계받는 '시니어 소프트웨어 아키텍트'의 역할을 수행한다.
분석 범위: .md 문서를 포함한 프로젝트 내의 모든 파일을 분석 범위에 포함한다.
출력 형식: 반드시 지정된 마크다운 목차와 형식을 따라야 한다. 코드 블록, 테이블, 리스트를 적극적으로 사용하여 가독성을 극대화해야 한다.
보안: .env 파일 분석 시, 실제 비밀 키 값은 [YOUR_JWT_SECRET], [YOUR_DATABASE_URL] 과 같은 플레이스홀더로 대체하여 출력해야 한다.
1.1. 프로젝트 핵심 목적: 이 애플리케이션의 주요 기능과 목적은 무엇인가? (예: AI 기반 콘텐츠 생성 및 관리 플랫폼) 1.2. 기술 스택 (Tech Stack): 사용된 주요 언어, 프레임워크, 라이브러리 목록을 테이블 형식으로 제공하라. * (예: TypeScript, Node.js, Express, React, bcrypt, jsonwebtoken, dotenv 등) 1.3. 프로젝트 파일 구조: tree 명령어와 유사한 형식으로 전체 파일 및 폴더 구조를 시각적으로 표현하라.

2.1. API 엔드포인트 전체 명세: server/routes/ 내의 모든 파일을 분석하여, 아래 형식의 테이블로 모든 API 엔드포인트를 문서화하라.

HTTP Method	URL Path	담당 파일	인증 필요 여부	간단한 설명	Request Body (JSON 형식)	Success Response (JSON 형식)
POST	/api/auth/login	auth.routes.ts	false	사용자 로그인 및 JWT 토큰 발급	{ "username", "password" }	{ "token", "user": { ... } }
POST	/api/auth/register	auth.routes.ts	false	신규 사용자 회원가입	{ "username", "email", ... }	{ "message", "userId" }
GET	/api/content	content.routes.ts	true	모든 콘텐츠 목록 조회	N/A	[{ "id", "title", ... }]
...	(나머지 모든 API)	...	...	...	...	...
2.2. 데이터베이스 스키마: server/storage.ts 파일의 모든 get, create, update, delete 함수를 분석하여 데이터베이스의 각 테이블 구조를 유추하고, 아래 형식의 테이블로 문서화하라.

users 테이블

Column	Data Type	Constraints	설명
id	INTEGER	PRIMARY KEY, SERIAL	사용자 고유 ID
username	STRING	UNIQUE, NOT NULL	사용자 로그인 아이디
email	STRING	UNIQUE, NOT NULL	사용자 이메일
password	STRING	NOT NULL	해싱된 비밀번호
role	STRING	NOT NULL	사용자 권한 (e.g., 'general')
hospitalId	INTEGER	FOREIGN KEY (추정)	소속 병원 ID
...	...	...	...
(다른 모든 테이블 - hospitals, contents 등에 대해서도 동일하게 작성)

2.3. 인증 및 권한 부여 로직: * JWT Payload: jwt.sign() 함수에 전달되는 객체의 구조를 정확히 명시하라. (예: { id, username, role, hospitalId }) * 인증 미들웨어 (authenticateToken): server/middleware/auth.ts의 로직을 단계별로 설명하라. 1. 헤더에서 토큰 추출 2. jwt.verify()를 사용한 토큰 검증 3. 병원 관리자(hospital_admin)의 경우, 병원 활성화 상태 추가 검증 4. req 객체에 user 정보 주입 * 비밀번호 해싱: bcrypt.hash()와 bcrypt.compare()가 어떻게 사용되는지 설명하라.

3.1. 컴포넌트 구조: src/components와 src/pages (또는 src/views) 폴더를 분석하여 주요 컴포넌트와 그 역할을 리스트로 요약하라. 3.2. 상태 관리 (State Management): 상태 관리 라이브러리(예: React Query, Zustand, Redux)가 사용되었다면, 그 설정과 핵심 로직을 설명하라. 3.3. API 연동: 프론트엔드에서 백엔드 API를 호출하는 주요 함수나 로직이 있다면, 어떤 컴포넌트가 어떤 API를 호출하는지 예시를 들어 설명하라.

4.1. AI API (Gemini): server/gemini.ts 파일을 분석하여 다음을 명시하라. * 사용되는 Gemini 모델 이름 (e.g., 'gemini-pro') * API 요청 시 generateContent 함수에 전달되는 request 객체의 전체 구조 * API 응답을 파싱하고 사용하는 방식

5.1. 필수 환경 변수: .env 파일 및 config.ts를 분석하여 애플리케이션 실행에 필요한 모든 환경 변수 목록과 각 변수의 역할을 아래 테이블 형식으로 제공하라.

변수명	설명	예시 값 (플레이스홀더)
JWT_SECRET	JWT 토큰 서명에 사용되는 비밀 키	[YOUR_UNIQUE_JWT_SECRET]
DATABASE_URL	데이터베이스 연결 주소	[YOUR_POSTGRES_DB_URL]
GEMINI_API_KEY	Google Gemini API 사용을 위한 키	[YOUR_GEMINI_API_KEY]
...	...	...
지금 즉시 분석을 시작하고, 위 명세서의 1번 섹션부터 순서대로 작성을 시작하라. 
