제공해주신 '창조AI 종합 시스템 아키텍처 및 로직 명세서'를 면밀히 검토했습니다.

현재 시스템의 잠재적 보완점과, 신규 결제 시스템 도입을 위한 최적화 방안을 정리하여 제안합니다.

---

## 1. 🎯 현재 시스템 분석 및 보완점 제안

시스템은 21개의 라우터 모듈과 38개의 데이터베이스 테이블을 갖춘 매우 정교하고 기능적으로 풍부한 애플리케이션입니다. 특히 AI 기능(음악, 이미지, 채팅)과 병원 관리, 마일스톤 시스템이 잘 통합되어 있습니다.

다만, 프로덕션 환경에서 발생할 수 있는 몇 가지 잠재적 위험 및 보완점을 제안합니다.

### 1.1 호스팅 및 확장성 (가용성)

* **현재 상태:** Replit 컨테이너의 '단일 Node.js 프로세스'로 프론트엔드 정적 서빙과 백엔드 API 서버를 동시에 실행 중입니다.
* **잠재적 문제:** **단일 장애점(SPOF)**입니다. 해당 Node.js 프로세스 하나에 장애가 발생하면, API 서버는 물론 프론트엔드 서비스까지 **전체 시스템이 중단**됩니다. 또한 트래픽 증가 시 수평적 확장이 어렵습니다.
* **보완 제안:**
    1.  **프론트엔드 분리:** 프론트엔드(Vite 빌드 결과물)는 Vercel, Netlify 또는 Google Cloud Storage 정적 호스팅을 통해 배포합니다.
    2.  **백엔드 컨테이너화:** 백엔드(Express)는 Docker로 컨테이너화한 후, **Google Cloud Run**이나 AWS Fargate와 같은 서버리스 컨테이너 플랫폼에 배포하여 트래픽에 따른 자동 확장 및 고가용성을 확보합니다.

### 1.2 인증 및 세션 관리 (복잡성)

* **현재 상태:** `JWT`와 `Firebase Auth`를 이중으로 사용하며, 동시에 `express-session` 및 `connect-pg-simple`을 통한 PostgreSQL 기반 세션 저장소를 사용합니다.
* **잠재적 문제:** JWT는 '무상태(Stateless)'를 지향하는 반면, `express-session`은 '상태유지(Stateful)' 방식입니다. 이 두 가지를 혼용하면 인증 로직이 불필요하게 복잡해지고, 서버리스 환경(예: Cloud Run)에서 세션 관리가 까다로워집니다.
* **보완 제안:**
    * **인증 방식 통일:** React SPA 환경이므로 **JWT(Stateless) 방식**을 주력으로 사용하고, `express-session`은 Google OAuth 콜백 처리 등 특정 흐름에서만 제한적으로 사용하거나 제거하는 것을 권장합니다. `JWTPayload`에 `memberType`, `hospitalId` 등 필수 정보가 이미 포함되어 있어 무상태 운영이 가능해 보입니다.

### 1.3 스토리지 보안 (민감 정보)

* **현재 상태:** "PUBLIC 배너 저장소 시스템"을 표방하며, `upload.ts` API 등이 Google Cloud Storage (PUBLIC) 버킷을 사용합니다.
* **잠재적 문제:** `milestone_application_files` (마일스톤 신청 파일) 또는 `images` (AI 변환 원본) 테이블은 사용자가 업로드한 개인적인 사진을 포함할 수 있습니다. 이 파일들을 PUBLIC 버킷에 저장하는 것은 (URL이 복잡하더라도) 보안상 위험할 수 있습니다.
* **보완 제안:**
    * **저장소 분리:** 문서의 호스팅 스택에 언급된 "PUBLIC/PRIVATE 분리" 원칙을 명확히 적용해야 합니다.
    * **PRIVATE 버킷 활용:** 마일스톤 신청 파일, AI 변환 원본 이미지 등 사용자 생성 콘텐츠는 **PRIVATE GCS 버킷**에 저장합니다.
    * **Signed URL 사용:** 사용자가 이 파일에 접근해야 할 때, 백엔드 API(`gcs-image-storage.ts` 로직 활용)를 통해 5~10분 정도 유효한 **임시 접근용 Signed URL**을 발급해주는 방식으로 변경해야 합니다.

### 1.4 모니터링 및 로깅

* **현재 상태:** `error-handler.ts` 외에 전문적인 오류 추적 및 모니터링 시스템이 명시되어 있지 않습니다.
* **잠재적 문제:** 21개의 라우터, 38개의 테이블, 다수의 외부 AI API 연동 등 시스템 복잡도 대비 오류 추적이 어렵습니다. AI API(OpenAI, TopMediai)의 응답 실패, DB 쿼리 오류 등을 신속하게 파악하기 어렵습니다.
* **보완 제안:**
    * **오류 추적 솔루션 도입:** Sentry, Datadog 등 애플리케이션 성능 모니터링(APM) 및 오류 추적 서비스를 도입하여 프로덕션 환경의 예외 상황을 실시간으로 수집하고 대응해야 합니다.

---

## 2. 💳 결제 시스템 도입 최적화 방안

현재 `users` 테이블에 `memberType` (free, pro, membership), `hospitals` 테이블에 `packageType` 등 유료 플랜을 위한 기반이 이미 마련되어 있습니다.

국내 환경에 최적화된 결제 시스템을 도입하기 위해 **PG(결제 대행사) 연동**을 제안하며, 현 스택(React, Express, Drizzle)에 가장 적합한 방안은 다음과 같습니다.

### 2.1 추천 결제 게이트웨이

* **아임포트 (PortOne)** 또는 **토스페이먼츠**를 추천합니다.
* **이유:** 이들은 다양한 결제 수단(카드, 간편결제, 계좌이체)을 한 번에 연동할 수 있는 API를 제공하며, 특히 구독형(정기) 결제 기능을 강력하게 지원합니다. 개발자 문서화가 매우 잘 되어 있습니다.

### 2.2 1단계: 데이터베이스 스키마 확장 (Drizzle)

기존 38개 테이블 외에 결제/구독 관리를 위한 3개의 핵심 테이블을 `shared/schema.ts`에 추가합니다.

**1. `products` (요금제) 테이블**

| Column | Data Type | 설명 |
|---|---|---|
| id | SERIAL | 요금제 ID |
| planId | VARCHAR(50) | 고유 플랜 ID (예: `pro_monthly_v1`) |
| name | TEXT | 요금제 이름 (예: "프로 월간 구독") |
| price | INTEGER | 금액 (KRW) |
| type | VARCHAR(20) | `subscription` (구독) / `one_time` (일회성) |
| interval | VARCHAR(10) | 청구 주기 (`month`, `year`, NULL) |
| isActive | BOOLEAN | 활성화 여부 |

**2. `transactions` (결제 내역) 테이블**

| Column | Data Type | 설명 |
|---|---|---|
| id | SERIAL | 결제 ID |
| userId | INTEGER | 사용자 ID (FK: `users`) |
| productId | INTEGER | 요금제 ID (FK: `products`) |
| **merchantUid** | VARCHAR(100) | **가맹점 주문번호 (필수, UNIQUE)** |
| **pgTransactionId** | VARCHAR(100) | **PG사 거래번호 (예: `imp_uid`)** |
| status | VARCHAR(20) | `pending`, `paid`, `failed`, `refunded` |
| amount | INTEGER | 실제 결제된 금액 |
| receiptUrl | TEXT | PG사 영수증 URL |
| paidAt | TIMESTAMP | 결제 완료 시간 |

**3. `subscriptions` (구독 상태) 테이블**

| Column | Data Type | 설명 |
|---|---|---|
| id | SERIAL | 구독 ID |
| userId | INTEGER | 사용자 ID (FK: `users`, UNIQUE) |
| productId | INTEGER | 요금제 ID (FK: `products`) |
| **pgSubscriptionId** | VARCHAR(100) | **PG사 정기결제 ID (예: `customer_uid`)** |
| status | VARCHAR(20) | `active`, `past_due`, `canceled` |
| currentPeriodEnd | TIMESTAMP | 현재 구독 종료일 (다음 결제일) |
| cancelAtPeriodEnd | BOOLEAN | 기간 만료 시 자동 해지 여부 |

**4. `users` 테이블 수정**
* `subscriptionId` (INTEGER, FK: `subscriptions`) 컬럼을 추가하여 사용자와 구독 상태를 연결합니다.
* `memberType`은 이제 `subscriptions.status`에 따라 동적으로 관리됩니다.

### 2.3 2단계: 백엔드 API 라우터 추가 (Express)

`server/routes/`에 `payment-routes.ts` 라우터 모듈을 신규 생성합니다.

**1. `GET /api/payments/plans` (요금제 목록 조회)**
* `products` 테이블에서 `isActive: true`인 요금제 목록을 조회하여 프론트엔드에 전달합니다.

**2. `POST /api/payments/request` (결제 요청 생성)**
* **로직:**
    1.  클라이언트에서 `planId`를 받습니다.
    2.  `products` 테이블에서 가격 정보를 조회합니다.
    3.  고유한 `merchantUid` (가맹점 주문번호)를 생성합니다.
    4.  `transactions` 테이블에 `status: 'pending'` 상태로 결제 요청 내역을 저장합니다.
    5.  아임포트(IMP)에 전달할 결제 요청 정보(주문번호, 금액, 상품명, 사용자 이메일 등)를 프론트엔드로 반환합니다.

**3. `POST /api/payments/webhook` (PG사 결제 알림 수신) - (가장 중요)**
* **로직:**
    1.  아임포트/토스 서버로부터 결제 완료/실패 알림(Webhook)을 수신합니다. (Body: `imp_uid`, `merchant_uid`, `status` 등)
    2.  **(필수) 서버사이드 검증:** 수신한 `imp_uid`와 `merchant_uid`를 이용해 다시 아임포트 API를 호출하여, **실제 결제된 금액**이 우리 DB(`transactions` + `products`)에 저장된 **예상 금액과 일치하는지** 검증합니다. (클라이언트 위변조 방지)
    3.  검증 성공 시 (e.g., `status == 'paid'`):
        * `transactions` 테이블의 상태를 `paid`로 업데이트합니다.
        * 정기결제인 경우, PG사 `customer_uid`를 받아 `subscriptions` 테이블을 생성/갱신합니다.
        * `users` 테이블의 `memberType`을 'pro' 또는 'membership'으로 업데이트하고, `subscriptionId`를 연결합니다.

**4. `POST /api/subscriptions/cancel` (구독 해지 요청)**
* **로직:**
    1.  사용자의 `subscriptions` 레코드를 찾습니다.
    2.  PG사에 `customer_uid`를 전달하여 정기결제 취소(예약)를 요청합니다.
    3.  `subscriptions` 테이블의 `cancelAtPeriodEnd` 플래그를 `true`로 설정합니다. (사용자는 `currentPeriodEnd`까지 서비스 이용 가능)

### 2.4 3단계: 프론트엔드 연동 (React, TanStack Query)

1.  **요금제 페이지 (`client/pages/Pricing.tsx`) 생성:**
    * `TanStack Query`를 사용해 `GET /api/payments/plans` API를 호출(캐싱)하여 요금제를 표시합니다.
2.  **결제 요청 (Mutation):**
    * 사용자가 "결제하기" 버튼 클릭 시 `POST /api/payments/request` (TanStack Mutation)을 호출합니다.
    * 백엔드에서 받은 결제 정보로 아임포트 JS SDK (`IMP.request_pay()`)를 실행하여 결제창을 띄웁니다.
3.  **결제 완료 처리:**
    * 결제가 완료되면 (PG사 콜백 수신), 사용자를 "결제 완료" 페이지로 리디렉션합니다.
    * 이때 **백그라운드에서는 2.3의 3단계(웹훅)가 처리**됩니다.
    * 클라이언트는 `TanStack Query`의 `queryClient.invalidateQueries(QueryKeys.currentUser)`를 실행하여 사용자 정보를 새로고침하고, 변경된 `memberType` (유료 등급)을 UI에 즉시 반영합니다.